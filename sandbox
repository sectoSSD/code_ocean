
def add (tuple_1, tuple_2, laps='',sector='') :
    if laps : return tuple_1[0] + tuple_2[0], tuple_1[1] + tuple_2[1], laps
    elif sector : return tuple_1[0] + tuple_2[0], tuple_1[1] + tuple_2[1], laps, sector
    else : return tuple_1[0] + tuple_2[0], tuple_1[1] + tuple_2[1]

def current_path(xy, path) : return list(map(lambda xy_path : add(xy, xy_path), path))

def sector (x,y) :
    sector = {'1': [0,5,0,5],  '2' : [0,5,5,10],  '3' : [0,5,10,15],
              '4': [5,10,0,5],  '5' : [5,10,5,10],  '6' : [5,10,10,15],
              '7': [10,15,0,5],'8' : [10,15,5,10],'9' : [10,15,10,15]}
    for i in '123456789' :
        if sector[i][0] <= x <= sector[i][1] and sector[i][2] <= y < sector[i][3] : return i
    return 'x'

###

def I_no_fork(temp_path,cursor,tile,brows_map,possible_path,start_cursor,start_tile,next_loop) :
    if add(temp_path[cursor][0], tile) not in brows_map:
        print(f'1A Pas d embranchement , obstacle : tile = {tile} fin')
        #return possible_path
        next_loop = False
    elif cursor == len(temp_path) - 1 :
        possible_path += 1
        if all(len(i) == 1 for i in temp_path) :
            print(f'1Ba Bout de temp_path sans embranchement avant : {possible_path} fin')
            #return possible_path
            next_loop = False
        else :
            print('1Bb Bout de temp_path avec embranchement avant : retour')
            cursor = start_cursor
            tile = start_tile
    else :
        tile = add(temp_path[cursor][0], tile)
        cursor = temp_path[cursor][0][2]
        print(f'1C On avance cursor = {cursor}, tile = {tile}')      
    return cursor, tile, possible_path, next_loop

def IIA_first_fork(temp_path, cursor, tile, start_cursor, start_tile) :
    if all(len(k) == 1 for k in temp_path[:cursor]) : 
        print(f'A : premier embranchement : startcursor {cursor}')
        return cursor, tile
    else : return  start_cursor, start_tile

def IIB_least_fork(temp_path, cursor, tile, branch, brows_map, start_cursor, start_tile) :
    if add(temp_path[cursor][branch], tile) not in  brows_map :
        temp_path[cursor].pop(branch)
        branch = (0,branch + 1)[branch == len(temp_path[cursor]) - 1]
        cursor = start_cursor
        tile = start_tile
        print('2Ba : dernière embranchement (dernière branche,autre branche) obstacle : retour')
    else :
        tile = add(temp_path[cursor][branch], tile)
        cursor = temp_path[cursor][branch][2]
        if branch == len(temp_path[cursor]) - 1 :
            if len(temp_path[start_cursor]) != 1 : temp_path[start_cursor].pop(0)
            branch += 1
            print(f'2Bb : dernière embranchement dernière branche On avance cursor = {cursor}, branche = {branch}, tile = {tile} ')
        else :
            branch = 0
            print(f'2Bc : dernière embranchement autre branche On avance cursor = {cursor}, branche = {branch}, tile = {tile} ')
    return temp_path, cursor, tile, branch

def IIC_least_fork_end_path(temp_path, cursor, tile, branch, brows_map, start_cursor, start_tile, possible_path):
    if add(temp_path[cursor][branch], tile) not in  brows_map :
        temp_path[cursor].pop(branch)
        # pas de branche+=1
        print('2Ca : dernière embranchement, dernière branche, Bout de temp_path et obstacle : retour')
    elif branch == len(temp_path[cursor]) - 1 :
        temp_path[start_cursor].pop(0)
        possible_path += 1
        branch = 0
        print('2Cb : dernière embranchement, dernière branche, Bout de temp_path : retour')
    else : 
        possible_path += 1
        branch += 1
        print('2Cc : dernière embranchement, autre branche, Bout de temp_path : retour')
    cursor = start_cursor
    tile = start_tile
    return temp_path, cursor, tile, branch, possible_path

def IID_other_fork(temp_path, cursor, tile, start_cursor, start_tile, brows_map) :
    if add(temp_path[cursor][0], tile) not in  brows_map:
        temp_path[cursor].pop(0)
        cursor = start_cursor
        tile = start_tile
        print('2Da Avec embranchement obstacle : retour')
    else :
        cursor = temp_path[cursor][0][2]
        tile = add(temp_path[cursor][0], tile)
        print(f'2Db On avance cursor = {cursor}, tile = {tile}')
    return temp_path, cursor, tile 

###

def run_map(brows_map,path) : 
    # brows_map designe une list de tuple sans les tuples des islands
    map_ = {}
    for start_tile in brows_map :
        temp_path = path.copy()
        map_[start_tile] = run_path(start_tile, brows_map, temp_path)
        print(f'next_tile : {start_tile}')
        print(f'path : {path}')
    print(f'fin de run_map : {map_}')
    return map_   

def run_path(start_tile, brows_map, temp_path):
    # list of list of tuples : [(x,y,laps,sector)],[()],[(),(),()],[()]
    """    
    1 Pas d'embranchement'
        A Obstacle
        B Bout de path 
            a sans embranchement avant 
            b avec embranchement avant
        C Autre : next cursor, tile
    2 Avec embranchement
        A Premier embranchement 
        B Dernière embranchement avec qqc après :
            a Obstacle : dernierère branche, autre branche
            b Pas d'obstacle derniere branche : next cursor, branche, tile
            c Pas d'obstacle autre branche : next cursor, branche, tile
        C Dernière embanchement en bout de path :
            a obstacle
            b Dernière Branche
            c Autre
        D Autre embranchement :
            a avec obstacle   
            b Autre : next cursor, tile
    """
    possible_path = 0
    start_cursor, cursor, branch = 0, 0, 0
    tile = start_tile
    next_loop = True
    
    while True :
        if len(temp_path[cursor]) == 1 :
            cursor, tile, possible_path, next_loop = I_no_fork(
                temp_path,cursor,tile,brows_map,possible_path,start_cursor,start_tile,next_loop)
            if next_loop == False : return possible_path
        else :
            start_cursor, start_tile = IIA_first_fork(
                temp_path, cursor, tile, start_cursor, start_tile)
            try :
                if all(len(i) == 1 for i in temp_path[cursor+1:]) :
                    temp_path, cursor, tile, branch = IIB_least_fork(
                        temp_path, cursor, tile, branch, brows_map, start_cursor, start_tile)  
            except IndexError :
                temp_path, cursor, tile, branch, possible_path = IIC_least_fork_end_path(
                    temp_path, cursor, tile, branch, brows_map, start_cursor, start_tile, possible_path)

            else :
                if any(len(i) != 1 for i in temp_path[cursor+1:]) :
                    temp_path, cursor, tile = IID_other_fork(
                        temp_path, cursor, tile, start_cursor, start_tile, brows_map)

def main():
    brows_map = [] # map de référence sans les îles
    island = []
    path = [[(-1,0,1)],[(0,1,2)],[(0,1,3)],[(1,0,4)],[(0,1,5)],[(1,0,6)],[(-3,0,7),(-2,0,7),(-1,0,7),(0,-3,7),(0,-2,7),(0,-1,7),(3,0,7),(2,0,7),(1,0,7),(0,3,7),(0,2,7),(0,1,7)],[(1,0,8)],[(0,-1,9)],[(1,0,10)],[(0,-1,11)],[(0,-1,12)],[(-1,0,13)],[(0,-1,14)],[(-3,0,15),(-2,0,15),(-1,0,15),(0,-3,15),(0,-2,15),(0,-1,15),(3,0,15),(2,0,15),(1,0,15),(0,3,15),(0,2,15),(0,1,15)],[(-1,0,16)],[(-1,0,17)],[(-1,0,18,8)]]
    for x in range(15) :
        for y in range(15) :
            if (x,y) not in island : brows_map.append((x,y))
    print(f'brows_map : {brows_map}')
    print(f'path : {path}')
    return run_map(brows_map,path)

if __name__ == '__main__' : main()


    
# 1 Parcours de la map a  partir de (7,7) de manière concentrique
#   a) Si ma case n'est pas dans island, je selection
#   b) Sinon je prend la case suivant

# 2 Creation d'un parcours de 16 tours le plus concentrique possible
#   a) Si je parviens au 16 tours sans island et dans la map, je selection
#   b) S'il reste d'autres possibilite, je recommance un autre parcours depuis la mÃªme case
#   c) Si j'ai epuisee les possbilites (comment mesurer ?) je reparts Ã  1

# 3 Mesure de la dilution du parcours au tours 16. 
#   a) Si la dilution Ã  t.16 est superieur a  25 / 225 : je garde
#   b) Sinon je relance le parcours a  2 qui peut me rediriger vers 1

