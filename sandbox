
### On essaye avec les classes

### paramÃ¨tre de test
island = [(2,2),(2,3),(3,2),(3,3)]


for x in range(15) :
    for y in range(15) :
        if in_island(x,y,island) : brows_map.append((x,y))
 ### fin
 
 ### fonction existante

def add (tuple_1, tuple_2,args='') :
    if args : return tuple_1[0] + tuple_2[0], tuple_1[1] + tuple_2[1], args
    else : return tuple_1[0] + tuple_2[0], tuple_1[1] + tuple_2[1]

def middle(x,y) :
    return 7-abs(7-x)+7-abs(7-y)


def in_island(x,y,island) :
    return (not (x,y) in island)

for x in range(15) :
    for y in range(15) :
        print(in_island(x,y,island))

def firs_lap(side):
    laps_to_charge_weapons = 16
    
    for xy in tile :
        while
        for laps in range(laps_to_charge_weapons):

### New I

def best_value(xy_list, function) :
    # ne fonction qu'avec une liste de tuples [(x,y),...]
    temp_value = 0
    temp_xy = (0,0)
    for xy in xy_list :
        cursor = function(xy)# 
        if cursor > temp_value :
            temp_value = cursor
            temp_xy = x,y
    return temp_xy

def one_step(xy, island,current_brows,brows_map) : 
    # retourn une list de tuple contenant des cases sans island
    new_step = (1,0),(-1,0),(0,1),(0,-1)
    new_tile = list(map(lambda x : add(xy,x), new_step))
    for tile in new_tile :
        if tile in island or tile in current_brows or tile not in brows_map :
            new_tile.remove(tile)
    return new_tile

def step(current_tile, next_tile) :
    return next_tile[0] - current_tile[0], next_tile[1] - current_tile[1]
          

class best_start():
    
    brows_map = []
    island = []
    current_map =[] # => map ou l'on supprime les starts non pertinent
    map_cursor = () # => temp_start
    brows_cursor = () #=> current_tile
    current_brows = []
    bad_brows = []
    current_path = [] #=> temp_path
    
    def __init__(self,brows_map,island): # faut tous les mettre ?
        
        self.brows_map = brows_map
        self.island = island
        self.current_map = current_map
        self.map_cursor = map_cursor
        self.brows_cursor = brows_cursor
        self.current_brows = current_brows
        self.bad_brows = bad_brows
        self.current_path = current_path
    
    def I_map(current_map) :

        while current_map :
            map_cursor = best_value(current_map, middle)
            # bad_brows,current_path deja definit
            
    def II_brows(map_cursor):
        
        brows_cursor = map_cursor
        current_brows = [map_cursor]
        
        while len(current_path) != 16 :
            possible_next_tiles = one_step(brows_cursor, island, current_brows, brows_map)
            
            while possible_next_tiles :
                next_tile = best_value(possible_next_tiles, middle)
                current_brows.append(next_tile)
                if current_brows in bad_brows :
                    current_brows.pop()
                    possible_next_tiles.remove(next_tile)
                else :
                    current_path.append(step(curent_tile, next_tile))
                    brows_cursor = next_tile
            else :
                if brows_cursor == map_cursor :
                    current_map.remove(map_cursor)
                    I_map(map_cursor)
                else :
                    bad_brows.append(current_brows)
                    current_brows = [map_cursor]
                
        else : III_dilution(current_path)
    
    def III_dilution


# on en est Ã  2 b il faudra faire des tests
        
    
# 1 Parcours de la map a  partir de (7,7) de manière concentrique
#   a) Si ma case n'est pas dans island, je selection
#   b) Sinon je prend la case suivant

# 2 Creation d'un parcours de 16 tours le plus concentrique possible
#   a) Si je parviens au 16 tours sans island et dans la map, je selection
#   b) S'il reste d'autres possibilite, je recommance un autre parcours depuis la mÃªme case
#   c) Si j'ai epuisee les possbilites (comment mesurer ?) je reparts Ã  1

# 3 Mesure de la dilution du parcours au tours 16. 
#   a) Si la dilution Ã  t.16 est superieur a  25 / 225 : je garde
#   b) Sinon je relance le parcours a  2 qui peut me rediriger vers 1

