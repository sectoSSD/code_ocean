### paramètre de test
island = [(2,2),(2,3),(3,2),(3,3)]


for x in range(15) :
    for y in range(15) :
        if in_island(x,y,island) : brows_map.append((x,y))
 ### fin
 
 ### fonction existante

def add (tuple_1, tuple_2,args='') :
    if args : return tuple_1[0] + tuple_2[0], tuple_1[1] + tuple_2[1], args
    else : return tuple_1[0] + tuple_2[0], tuple_1[1] + tuple_2[1]

def middle(x,y) :
    return 7-abs(7-x)+7-abs(7-y)


def in_island(x,y,island) :
    return (not (x,y) in island)

for x in range(15) :
    for y in range(15) :
        print(in_island(x,y,island))

def firs_lap(side):
    laps_to_charge_weapons = 16
    
    for xy in tile :
        while
        for laps in range(laps_to_charge_weapons):

### New

def best_value(xy_list, function) :
    # ne fonction qu'avec une liste de tuples [(x,y),...]
    temp_value = 0
    temp_xy = (0,0)
    for xy in xy_list :
        cursor = function(xy)# 
        if cursor > temp_value :
            temp_value = cursor
            temp_xy = x,y
    return temp_xy

def one_step(xy, island,already_brows) : 
    # retourn une list de tuple contenant des cases sans island
    new_step = (1,0),(-1,0),(0,1),(0,-1)
    new_tile = list(map(lambda x : add(xy,x), new_step))
    for tile in new_tile :
        if tile in island or tile in already_brows:
            new_tile.remove(tile)
    return new_tile

def step(current_tile, next_tile) :
    return next_tile[0] - current_tile[0], next_tile[1] - current_tile[1]
          
def best_start(brows_map,island) :
    temp_value = 0
    temp_xy = (7,7)
    while brows_map :
        temp_start = best_value(brows_map, middle)
        current_tile = temp_start
        already_brows = [temp_start]
        temp_path = []
        while len(temp_path) != 16 :
            possible_next_tiles = one_step(current_tile,island,already_brows)
            if possible_next_steps :
                next_tile = best_value(possible_next_tiles, middle)
                already_brows.append(next_tile)
                temp_path.append(step(curent_tile, next_tile))
                current_tile = next_tile.copy()
            # on en est à 2 b il faudra faire des tests
        
    
# 1 Parcours de la map à partir de (7,7) de manière concentrique
#   a) Si ma case n'est pas dans island, je selection
#   b) Sinon je prend la case suivant

# 2 Création d'un parcours de 16 tours le plus concentrique possible
#   a) Si je parviens au 16 tours sans island et dans la map, je selection
#   b) S'il reste d'autres possibilité, je recommance un autre parcours depuis la même case
#   c) Si j'ai épuisé les possbilités (comment mesurer ?) je reparts à 1

# 3 Mesure de la dilution du parcours au tours 16. 
#   a) Si la dilution à t.16 est supérieur à 25 / 225 : je garde
#   b) Sinon je relance le parcours à 2 qui peut me rediriger vers 1
