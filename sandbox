#def
def move (direction,laps) :
    l_ = laps + 1
    step = { 'N' : [(-1,0,l_)], 
             'S' : [(1,0,l_)], 
             'E' : [(0,1,l_)], 
             'O' : [(0,-1,l_)], 
            'Silence' : [(-3,0,l_),(-2,0,l_),(-1,0,l_),(0,-3,l_),(0,-2,l_),(0,-1,l_),
                         (3,0,l_),(2,0,l_),(1,0,l_),(0,3,l_),(0,2,l_),(0,1,l_)]}
    return step[direction]
        
# entr√©e
path = []
direction = ['N','N','N','O','O','Silence','S','S']
island = [(0,-3),(0,2),(0,-2)]
for i in range(len(direction)) :
    path.append(move(direction[i],i))

print(path)

def run_path(path,island): # nb : un seul 'sielence' possible
# list of list of tuples : [(x,y,laps)],[()],[(),(),()],[()]
    possible_path = 0
    i,j = 0,0
    loop = 'x'
    while True :
        if i == len(path) : # 3 en bout de path
            possible_path += 1
            if loop == 'o':
                i = 0
            else : 
                return possible_path
        if  len(path[i]) == 1 and path[i][0][0:2] in island or not 0 <= path[i][0][0] <= side or not 0 <= path[i][0][1] <= side : # sur un island sans embranchement ou hors-jeu
            return possible_path
        if len(path[i]) != 1 : # 2 a un enbranchement
            if j == len(path[i]) - 1 : 
                loop = 'x'
                if path[i][j][0:2] in island :
                    return possible_path 
            else :
                j += 1
                loop = 'o'
                if path[i][j][0:2] in island :
                    i = 0
        i = path[i][0][2]
print(run_path(path,island))
