"""
    my_command : list with all(?) my previous command
    my_order : list of list of tuples with all my move as perceived by my enemy
    already  : all the tiles where i have allready been
    his_order : list of list of tuples with all his possible move : 
                can suppot only one silence without beeing deleted
"""

# parameters

max_path = 5 # ??
his_silence_count, his_laps = 0,0
dilution_rate = 81//225

# input

"""
At the beginning :
input 1 -> width, height, my_id -> 
input 1 -> brows_map, island

At each round :
input 1 -> x, y, my_life, his_life, torpedo, sonar, silence, mc
input 2 -> sonar_result
input 3 -> his_order
"""

def side() :
    width, height, my_id = [int(i) for i in input().split()] # we use 'side' witch is 15
    return width, height, my_id

def map_(width, height):
    brows_map, island = [],[]
    for y in range(height) :
        line = input()
        for x in range(width) :
            if line[x] == 'x' : island.append((x,y)) # x -> island else .
            else : brows_map.append((x,y))
    return brows_map, island
# input 1
# input 2
def his_order():
    
    his_order = input().replace('|', ' ').split() # his_order = ['move','N','Torpedo]
    his_path = []

    if 'MOVE' in his_order :
        his_path.append(move(direction(his_order),his_laps))
        his_laps += 1 # laps start from 0
    else : 
        if 'SILENCE' in his_order :
            his_silence_count += 1
            if his_silence_count > 1 : # if there is two silence we restat from 0, no path for this turn
                his_path = []
                his_laps = 0
                his_silence_count = 0         
# tools

def iter_path(path) : 
    for step in path : yield step

def iter_laps():
    for laps in range(1,302): yield laps

def add (tuple_1, tuple_2,args='') :
    if args : return tuple_1[0] + tuple_2[0], tuple_1[1] + tuple_2[1], args
    else : return tuple_1[0] + tuple_2[0], tuple_1[1] + tuple_2[1]

def middle(xy) :
    x,y = xy
    return 7-abs(7-x) + 7-abs(7-y) + min(7-abs(7-x), 7-abs(7-y)) # Manhattan + Euclidienne

def step(current_tile, next_tile) :
    return next_tile[0] - current_tile[0], next_tile[1] - current_tile[1]
 
def current_path(xy,path) : return list(map(lambda x : add(xy,x), path))

def sector (x,y) :
    sector = {'1': [0,5,0,5],  '2' : [0,5,5,10],  '3' : [0,5,10,15],
              '4': [5,10,0,5],  '5' : [5,10,5,10],  '6' : [5,10,10,15],
              '7': [10,15,0,5],'8' : [10,15,5,10],'9' : [10,15,10,15]}
    for i in '123456789' :
        if sector[i][0] <= x <= sector[i][1] and sector[i][2] <= y < sector[i][3] : return i
    return 'x'

# Converter

def move (order) : # direction ==> move 
    r = ''
    if 'MOVE' in order :
        if 'N' in order : r = 'N'
        if 'S' in order : r = 'S'
        if 'E' in order : r = 'E'
        if 'W' in order : r = 'W'
        if 'SILENCE' in order : r = 'Silence'
    if 'SURFACE' in order or 'SONAR' in order :
        for i in '123456789' : if i in order : r 
    return r

"""
def move (direction,laps) :
    l_ = laps + 1
    step = { 'N' : [(0,-1,l_)], 
             'S' : [(0,1,l_)], 
             'E' : [(1,-1,l_)], 
             'W' : [(-1,0,l_)], 
            'Silence' : [(-3,0,l_),(-2,0,l_),(-1,0,l_),(0,-3,l_),(0,-2,l_),(0,-1,l_),
                         (3,0,l_),(2,0,l_),(1,0,l_),(0,3,l_),(0,2,l_),(0,1,l_)]}
    return step[direction]
"""

def dir_path_conv(dir_path) :
    step = { 
             'N'     : ( 0,-1),
             'S'     : ( 0, 1),
             'E'     : ( 1, 0),
             'W'     : (-1, 0),
            ( 0,-1 ) : 'N',
            ( 0, 1 ) : 'S',
            ( 1, 0 ) : 'E',
            (-1, 0 ) : 'W'
                                }
    return step[dir_path]

# LEVEL 3

def best_value(xy_list, function) :
    # ne fonction qu'avec une liste de tuples [(x,y),...]
    temp_value = 0
    temp_xy = (0,0)
    for xy in xy_list :
        cursor = function(xy)# 
        if cursor > temp_value :
            temp_value = cursor
            temp_xy = xy
    return temp_xy

def one_step(xy, current_brows, brows_map) : 
    # retourn une list de tuple contenant des cases sans island
    new_step = (1,0),(-1,0),(0,1),(0,-1)
    new_tile = []
    for tile in current_path(xy,new_step) :
        if tile in current_brows or tile not in brows_map :
            pass
        else : new_tile.append(tile)
    return new_tile
      
def test_path(path, brows_map) :
    possible_tile = 0
    for brows_tile in brows_map :
        for path_tile in current_path(brows_tile,path) :
            if path_tile not in brows_map : break# (mieux a faire mais bon ...)
        else : possible_tile += 1
    return possible_tile    

# LEVEL 2

def start_I_map(current_map, brows_map) :

    while current_map :
        map_cursor = best_value(current_map, middle)
        return start_II_brows(current_map, brows_map, map_cursor)
  
def start_II_brows(current_map, brows_map, map_cursor) :
    
    current_path = []
    bad_brows = []
    brows_cursor = map_cursor
    current_brows = [map_cursor]
    
    while len(current_path) != 16 :
        possible_next_tiles = one_step(brows_cursor, current_brows, brows_map)
        
        while possible_next_tiles :
            next_tile = best_value(possible_next_tiles, middle)
            current_brows.append(next_tile)
            if current_brows in bad_brows :
                current_brows.pop()
                possible_next_tiles.remove(next_tile)
            else :
                current_path.append(step(brows_cursor, next_tile))
                brows_cursor = next_tile
                break
        else :
            if brows_cursor == map_cursor :
                current_map.remove(map_cursor)
                return start_I_map(current_map, brows_map)
            else :
                bad_brows.append(current_brows)
                current_brows = [map_cursor]  
                brows_cursor = map_cursor
    else : 
        return start_III_dilution(current_map, map_cursor, current_path, brows_map, dilution_rate)

def start_III_dilution(current_map, map_cursor, current_path, brows_map, dilution_rate): # add : 
    if test_path(current_path,brows_map) / len(brows_map) > dilution_rate :
        return map_cursor, current_path
    else : 
        current_map.remove(map_cursor)
        return start_I_map(current_map, brows_map)    

# LEVEL 1

def start(brows_map):          
    current_map = brows_map.copy() # ???
    return start_I_map(current_map, brows_map) # <===== First LAP

def game_loop(brows_map,path) : # ICI
    first_steps = iter_path(path)
    rev_counter = iter_laps()
    
    while True:
        
        x, y, my_life, his_life, torpedo, sonar, silence, mc = [int(i) for i in input().split()]
        sonar_result = input()
        laps = next(rev_counter)
        his_order()
        
        print(f'MOVE {dir_path_conv(next(first_steps))}')

    if his_path :
        map_ = run_map(brows_map,his_path,island)
        print(f'MOVE N SILENCE | MSG {map_}')
    else : print('MOVE N SILENCE')

    already.append((x,y))
    decision, max_, isit = d_isit(his_order, max_, island)
    if decision != 'wait' : z, result = hunt(x, y, isit, already, torpedo)
    else : z, result = wait(x, y, silence, island, already)
    if z == 'x' : already = []
    print(result)
        # f'| MSG {isit}'

def run_map(brows_map,path,island) : # brows_map designe une list de tuple sans les tuples des islands
    map_ = {}
    for xy in brows_map :
        map_[xy] = run_path(current_path(xy,path),island)
    return map_   

def run_path(path,brows_map): # nb : un seul 'sielence' possible
# list of list of tuples : [(x,y,laps)],[()],[(),(),()],[()]
    possible_path = 0
    i,j = 0,0
    loop = 'x'
    while True :
        if i == len(path) : # 3 en bout de path
            possible_path += 1
            if loop == 'o':
                i = 0
            else : 
                return possible_path
        if len(path[i]) == 1 :
            if path[i][0][0:2] not in brows_map: # sur un island sans embranchement ou hors-jeu
                return possible_path
        if len(path[i]) != 1 : # 2 a un enbranchement
            if j == len(path[i]) - 1 : 
                loop = 'x'
                if path[i][j][0:2] not in brows_map :
                    return possible_path 
            else :
                j += 1
                loop = 'o'
                if path[i][j][0:2] not in brows_map :
                    i = 0
        i = path[i][0][2]

# Play :

if __name__ == '__main__' : 
    width, height, my_id = side()
    brows_map, island = map_(width, height)
    start, path = start(brows_map)
    print(*start,sep=' ')
    game_loop(brows_map,path)
