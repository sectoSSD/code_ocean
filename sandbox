
def add (tuple_1, tuple_2, laps='',sector='') :
    if laps : return tuple_1[0] + tuple_2[0], tuple_1[1] + tuple_2[1], laps
    elif sector : return tuple_1[0] + tuple_2[0], tuple_1[1] + tuple_2[1], laps, sector
    else : return tuple_1[0] + tuple_2[0], tuple_1[1] + tuple_2[1]

def current_path(xy, path) : return list(map(lambda xy_path : add(xy, xy_path), path))

def sector (x,y) :
    sector = {'1': [0,5,0,5],  '2' : [0,5,5,10],  '3' : [0,5,10,15],
              '4': [5,10,0,5],  '5' : [5,10,5,10],  '6' : [5,10,10,15],
              '7': [10,15,0,5],'8' : [10,15,5,10],'9' : [10,15,10,15]}
    for i in '123456789' :
        if sector[i][0] <= x <= sector[i][1] and sector[i][2] <= y < sector[i][3] : return i
    return 'x'

def run_map(brows_map,path) : # brows_map designe une list de tuple sans les tuples des islands
    map_ = {}
    #for xy in brows_map :
    xy = (1,1)
    map_[xy] = run_path(xy, brows_map, path)
    return map_   

def run_path(xy, brows_map, path): # nb : un seul 'sielence' possible
# list of list of tuples : [(x,y,laps,sector)],[()],[(),(),()],[()]
    possible_path = 0
    
    i,j = 0,0
    loop = 'x'
    while True :
        if i == len(path) : # en bout de path
            print('en bout de path')
            possible_path += 1
            if loop == 'o':
                print('nouveau path')
                i = 0
            else : 
                return possible_path
        if len(path[i]) == 1 and add(path[i][0], xy) not in brows_map: # sur un island sans embranchement ou hors-jeu
                print('sur un island sans embranchement ou hors-jeu')
                return possible_path
        if len(path[i]) != 1 : # a un enbranchement
            print('a un enbranchement')
            if j == len(path[i]) - 1 : # en dernière branche
                print('en dernière branche')
                if all(len(k) == 1 for k in path[i:]) : # en dernière embranchement
                    print('en dernière embranchement')
                    loop = 'x'
                    if add(path[i][j], xy) not in brows_map :
                        print('obstacle')
                        return possible_path
                else : 
                    print('encore un embranchement')
                    j = 0
            else :
                print('nouvelle branche')
                if add(path[i][j], xy) not in brows_map :
                    i = 0
                else :
                    j += 1
                    loop = 'o'
        print(f'on avance {path[i][0][2]}')
        i = path[i][0][2]



def main():
    
    brows_map = [] # map de référence sans les îles
    island = []
    path = [[(-1,0,1)],[(0,1,2)],[(0,1,3)],[(1,0,4)],[(0,1,5)],[(1,0,6)],[(-3,0,7),(-2,0,7),(-1,0,7),(0,-3,7),(0,-2,7),(0,-1,7),(3,0,7),(2,0,7),(1,0,7),(0,3,7),(0,2,7),(0,1,7)],[(1,0,8)],[(0,-1,9)],[(1,0,10)],[(0,-1,11)],[(0,-1,12)],[(-1,0,13)],[(0,-1,14)],[(-3,0,15),(-2,0,15),(-1,0,15),(0,-3,15),(0,-2,15),(0,-1,15),(3,0,15),(2,0,15),(1,0,15),(0,3,15),(0,2,15),(0,1,15)],[(-1,0,16)],[(-1,0,17)],[(-1,0,18,8)]]
    for x in range(15) :
        for y in range(15) :
            if (x,y) not in island : brows_map.append((x,y))
    print(f'brows_map : {brows_map}')
    print(f'path : {path}')
    return run_map(brows_map,path)

if __name__ == '__main__' : main()


    
# 1 Parcours de la map a  partir de (7,7) de manière concentrique
#   a) Si ma case n'est pas dans island, je selection
#   b) Sinon je prend la case suivant

# 2 Creation d'un parcours de 16 tours le plus concentrique possible
#   a) Si je parviens au 16 tours sans island et dans la map, je selection
#   b) S'il reste d'autres possibilite, je recommance un autre parcours depuis la mÃªme case
#   c) Si j'ai epuisee les possbilites (comment mesurer ?) je reparts Ã  1

# 3 Mesure de la dilution du parcours au tours 16. 
#   a) Si la dilution Ã  t.16 est superieur a  25 / 225 : je garde
#   b) Sinon je relance le parcours a  2 qui peut me rediriger vers 1
