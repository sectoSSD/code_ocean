import copy

def add (tuple_1, tuple_2, laps='',sector='') :
    if laps : return tuple_1[0] + tuple_2[0], tuple_1[1] + tuple_2[1], laps
    elif sector : return tuple_1[0] + tuple_2[0], tuple_1[1] + tuple_2[1], laps, sector
    else : return tuple_1[0] + tuple_2[0], tuple_1[1] + tuple_2[1]

def current_path(xy, path) : return list(map(lambda xy_path : add(xy, xy_path), path))

def sector (x,y) :
    sector = {'1': [0,5,0,5],  '2' : [0,5,5,10],  '3' : [0,5,10,15],
              '4': [5,10,0,5],  '5' : [5,10,5,10],  '6' : [5,10,10,15],
              '7': [10,15,0,5],'8' : [10,15,5,10],'9' : [10,15,10,15]}
    for i in '123456789' :
        if sector[i][0] <= x <= sector[i][1] and sector[i][2] <= y < sector[i][3] : return i
    return 'x'

###

def I_no_fork(temp_path,cursor,tile,brows_map,possible_path,start_cursor,start_tile,next_loop) :
    if add(temp_path[cursor][0], tile) not in brows_map:
        print(f'1A Pas d embranchement , obstacle : tile = {tile} fin')
        next_loop = False
    elif cursor == len(temp_path) - 1 :
        possible_path += 1
        if all(len(i) == 1 for i in temp_path) :
            print(f'1Ba Bout de temp_path sans embranchement avant : {possible_path} fin')
            next_loop = False
        else :
            print('1Bb Bout de temp_path avec embranchement avant : retour')
            cursor = start_cursor
            tile = start_tile
    else :
        tile = add(temp_path[cursor][0], tile)
        cursor = temp_path[cursor][0][2]
        #print(f'1C On avance cursor = {cursor}, tile = {tile}')      
    return cursor, tile, possible_path, next_loop

def IIA_first_fork(temp_path, cursor, tile, start_cursor, start_tile) :
    if all(len(k) == 1 for k in temp_path[:cursor]) : 
        print(f'A : premier embranchement : startcursor {cursor}')
        return cursor, tile
    else : return  start_cursor, start_tile

def IIB_least_fork(temp_path, cursor, tile, branch, brows_map, start_cursor, start_tile) :
    if add(temp_path[cursor][branch], tile) not in  brows_map :
        temp_path[cursor].pop(branch)
        branch = (0,branch + 1)[branch == len(temp_path[cursor]) - 1]
        cursor = start_cursor
        tile = start_tile
        print('2Ba : dernière embranchement (dernière branche,autre branche) obstacle : retour')
    else :
        #tile = add(temp_path[cursor][branch], tile)
        #cursor = temp_path[cursor][branch][2]
        if branch == len(temp_path[cursor]) - 1 :
            if len(temp_path[start_cursor]) != 1 : temp_path[start_cursor].pop(0)
            #branch += 1
            branch = 0
            print(f'2Bb : dernière embranchement dernière branche On avance cursor = {cursor}, branche = {branch}, tile = {tile} ')
        else :
            #branch = 0
            branch += 1
            print(f'2Bc : dernière embranchement autre branche On avance cursor = {cursor}, branche = {branch}, tile = {tile} ')
        tile = add(temp_path[cursor][branch], tile)
        cursor = temp_path[cursor][branch][2]
    return temp_path, cursor, tile, branch

def IIC_least_fork_end_path(temp_path, cursor, tile, branch, brows_map, start_cursor, start_tile, possible_path):
    if add(temp_path[cursor][branch], tile) not in  brows_map :
        temp_path[cursor].pop(branch)
        print('2Ca : dernière embranchement, dernière branche, Bout de temp_path et obstacle : retour')
    elif branch == len(temp_path[cursor]) - 1 :
        temp_path[start_cursor].pop(0)
        possible_path += 1
        branch = 0
        print('2Cb : dernière embranchement, dernière branche, Bout de temp_path : retour')
    else : 
        possible_path += 1
        branch += 1
        print('2Cc : dernière embranchement, autre branche, Bout de temp_path : retour')
    cursor = start_cursor
    tile = start_tile
    return temp_path, cursor, tile, branch, possible_path

def IID_other_fork(temp_path, cursor, tile, start_cursor, start_tile, brows_map) :
    if add(temp_path[cursor][0], tile) not in  brows_map:
        temp_path[cursor].pop(0)
        cursor = start_cursor
        tile = start_tile
        print('2Da Avec embranchement obstacle : retour')
    else :
        cursor = temp_path[cursor][0][2]
        tile = add(temp_path[cursor][0], tile)
        print(f'2Db On avance cursor = {cursor}, tile = {tile}')
    return temp_path, cursor, tile 

###

def run_map(brows_map,path) : 
    # brows_map designe une list de tuple sans les tuples des islands
    map_ = {}
    for start_tile in brows_map :
        temp_path = copy.deepcopy(path)
        map_[start_tile] = run_path(start_tile, brows_map, temp_path)
        print(f'next_tile : {start_tile}')
    print(f'fin de run_map : {map_}')
    return map_   

def run_path(start_tile, brows_map, temp_path):
    # list of list of tuples : [(x,y,laps,sector)],[()],[(),(),()],[()]
    """    
    1 Pas d'embranchement'
        A Obstacle
        B Bout de path 
            a sans embranchement avant 
            b avec embranchement avant
        C Autre : next cursor, tile
    2 Avec embranchement
        A Premier embranchement 
        B Dernière embranchement avec qqc après :
            a Obstacle : dernierère branche, autre branche
            b Pas d'obstacle derniere branche : next cursor, branche, tile
            c Pas d'obstacle autre branche : next cursor, branche, tile
        C Dernière embanchement en bout de path :
            a obstacle
            b Dernière Branche
            c Autre
        D Autre embranchement :
            a avec obstacle   
            b Autre : next cursor, tile
    """
    possible_path = 0
    start_cursor, cursor, branch = 0, 0, 0
    tile = start_tile
    next_loop = True
    
    while True :
        if len(temp_path[cursor]) == 1 :
            cursor, tile, possible_path, next_loop = I_no_fork(
                temp_path,cursor,tile,brows_map,possible_path,start_cursor,start_tile,next_loop)
            if next_loop == False : return possible_path
        else :
            start_cursor, start_tile = IIA_first_fork(
                temp_path, cursor, tile, start_cursor, start_tile)
            try :
                if all(len(i) == 1 for i in temp_path[cursor+1:]) :
                    temp_path, cursor, tile, branch = IIB_least_fork(
                        temp_path, cursor, tile, branch, brows_map, start_cursor, start_tile)  
            except IndexError :
                temp_path, cursor, tile, branch, possible_path = IIC_least_fork_end_path(
                    temp_path, cursor, tile, branch, brows_map, start_cursor, start_tile, possible_path)

            else :
                if any(len(i) != 1 for i in temp_path[cursor+1:]) :
                    temp_path, cursor, tile = IID_other_fork(
                        temp_path, cursor, tile, start_cursor, start_tile, brows_map)

def main():
    brows_map = [] # map de référence sans les îles
    island = []
    path = [[(-1, 0, 1)], [(0, 1, 2)], [(1, 0, 3)], [(1, 0, 4)], [(0, -1, 5)], [(0, -1, 6)], 
            [(-1, 0, 7)], [(-1, 0, 8)], [(-1, 0, 9)], [(0, 1, 10)], [(0, 1, 11)], [(0, 1, 12)], 
            [(1, 0, 13), (0,1,13)], 
            [(1, 0, 14)], [(1, 0, 15)], [(1, 0, 16)], [(0, -1, 17)], [(0, -1, 18)], [(0, -1, 19)]]

    for x in range(15) :
        for y in range(15) :
            if (x,y) not in island : brows_map.append((x,y))
    print(f'brows_map : {brows_map}')
    print(f'path : {path}')
    return run_map(brows_map,path)

if __name__ == '__main__' : main()

"""
jupyter :

# on met path dans spider :

path = [[(-1, 0, 1)], [(0, 1, 2)], [(1, 0, 3)], [(1, 0, 4)], [(0, -1, 5)], [(0, -1, 6)], 
        [(-1, 0, 7)], [(-1, 0, 8)], [(-1, 0, 9)], [(0, 1, 10)], [(0, 1, 11)], [(0, 1, 12)], 
        [(1, 0, 13), (0,1,13)], 
        [(1, 0, 14)], [(1, 0, 15)], [(1, 0, 16)], [(0, -1, 17)], [(0, -1, 18)], [(0, -1, 19)]]

# on obtient le run_map suivant : c'est pas notmal qu'il n'y ai pas de '1'
map_ = {(0, 0): 0, (0, 1): 0, (0, 2): 0, (0, 3): 0, (0, 4): 0, (0, 5): 0, (0, 6): 0, (0, 7): 0, (0, 8): 0, (0, 9): 0, (0, 10): 0, (0, 11): 0, (0, 12): 0, (0, 13): 0, (0, 14): 0, (1, 0): 0, (1, 1): 0, (1, 2): 0, (1, 3): 0, (1, 4): 0, (1, 5): 0, (1, 6): 0, (1, 7): 0, (1, 8): 0, (1, 9): 0, (1, 10): 0, (1, 11): 0, (1, 12): 0, (1, 13): 0, (1, 14): 0, (2, 0): 0, (2, 1): 2, (2, 2): 2, (2, 3): 2, (2, 4): 2, (2, 5): 2, (2, 6): 2, (2, 7): 2, (2, 8): 2, (2, 9): 2, (2, 10): 2, (2, 11): 2, (2, 12): 0, (2, 13): 0, (2, 14): 0, (3, 0): 0, (3, 1): 2, (3, 2): 2, (3, 3): 2, (3, 4): 2, (3, 5): 2, (3, 6): 2, (3, 7): 2, (3, 8): 2, (3, 9): 2, (3, 10): 2, (3, 11): 2, (3, 12): 0, (3, 13): 0, (3, 14): 0, (4, 0): 0, (4, 1): 2, (4, 2): 2, (4, 3): 2, (4, 4): 2, (4, 5): 2, (4, 6): 2, (4, 7): 2, (4, 8): 2, (4, 9): 2, (4, 10): 2, (4, 11): 2, (4, 12): 0, (4, 13): 0, (4, 14): 0, (5, 0): 0, (5, 1): 2, (5, 2): 2, (5, 3): 2, (5, 4): 2, (5, 5): 2, (5, 6): 2, (5, 7): 2, (5, 8): 2, (5, 9): 2, (5, 10): 2, (5, 11): 2, (5, 12): 0, (5, 13): 0, (5, 14): 0, (6, 0): 0, (6, 1): 2, (6, 2): 2, (6, 3): 2, (6, 4): 2, (6, 5): 2, (6, 6): 2, (6, 7): 2, (6, 8): 2, (6, 9): 2, (6, 10): 2, (6, 11): 2, (6, 12): 0, (6, 13): 0, (6, 14): 0, (7, 0): 0, (7, 1): 2, (7, 2): 2, (7, 3): 2, (7, 4): 2, (7, 5): 2, (7, 6): 2, (7, 7): 2, (7, 8): 2, (7, 9): 2, (7, 10): 2, (7, 11): 2, (7, 12): 0, (7, 13): 0, (7, 14): 0, (8, 0): 0, (8, 1): 2, (8, 2): 2, (8, 3): 2, (8, 4): 2, (8, 5): 2, (8, 6): 2, (8, 7): 2, (8, 8): 2, (8, 9): 2, (8, 10): 2, (8, 11): 2, (8, 12): 0, (8, 13): 0, (8, 14): 0, (9, 0): 0, (9, 1): 2, (9, 2): 2, (9, 3): 2, (9, 4): 2, (9, 5): 2, (9, 6): 2, (9, 7): 2, (9, 8): 2, (9, 9): 2, (9, 10): 2, (9, 11): 2, (9, 12): 0, (9, 13): 0, (9, 14): 0, (10, 0): 0, (10, 1): 2, (10, 2): 2, (10, 3): 2, (10, 4): 2, (10, 5): 2, (10, 6): 2, (10, 7): 2, (10, 8): 2, (10, 9): 2, (10, 10): 2, (10, 11): 2, (10, 12): 0, (10, 13): 0, (10, 14): 0, (11, 0): 0, (11, 1): 2, (11, 2): 2, (11, 3): 2, (11, 4): 2, (11, 5): 2, (11, 6): 2, (11, 7): 2, (11, 8): 2, (11, 9): 2, (11, 10): 2, (11, 11): 2, (11, 12): 0, (11, 13): 0, (11, 14): 0, (12, 0): 0, (12, 1): 2, (12, 2): 2, (12, 3): 2, (12, 4): 2, (12, 5): 2, (12, 6): 2, (12, 7): 2, (12, 8): 2, (12, 9): 2, (12, 10): 2, (12, 11): 2, (12, 12): 0, (12, 13): 0, (12, 14): 0, (13, 0): 0, (13, 1): 2, (13, 2): 2, (13, 3): 2, (13, 4): 2, (13, 5): 2, (13, 6): 2, (13, 7): 2, (13, 8): 2, (13, 9): 2, (13, 10): 2, (13, 11): 2, (13, 12): 0, (13, 13): 0, (13, 14): 0, (14, 0): 0, (14, 1): 0, (14, 2): 0, (14, 3): 0, (14, 4): 0, (14, 5): 0, (14, 6): 0, (14, 7): 0, (14, 8): 0, (14, 9): 0, (14, 10): 0, (14, 11): 0, (14, 12): 0, (14, 13): 0, (14, 14): 0}
array = np.array(list(map_.values())).reshape(-1,15)
array
"""
