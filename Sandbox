# debug

def debug_map(content, game_map) :
    # give graphics overview of the value of each tiles, content is a dic with tuple (x,y) as key
    for y in range(game_map['size']):
        line = []
        for x in range(game_map['size']):
            try : line.append(f'{content[x,y]:02}')
            except KeyError : line.append('XX')
        print(*line, sep=' ')   

def debug_path(path, show_path = False):
    tile_cursor = (0,0)
    path_cursor = [tile_cursor]
    for direction in path :
        tile_cursor = add_tuple(tile_cursor, direction[0])
        path_cursor.append( tile_cursor)
    
    min_x = min([xy[0] for xy in path_cursor])
    min_y = min([xy[1] for xy in path_cursor])
    correction = -min_x, -min_y
    path_cursor = list(map(lambda xy : add_tuple(xy, correction),path_cursor))
    path_cursor = { key : value for value,key in enumerate(path_cursor) }
    max_x = max([xy[0] for xy in path_cursor])
    max_y = max([xy[1] for xy in path_cursor])
    spread = abs(max_x - min_x) * abs(max_y - min_y)
    
    if show_path == True :
        for y in range(max_y + 1) :
            line = []
            for x in range(max_x + 1) :
                if (x,y) in path_cursor :
                    line.append(f'{path_cursor[(x,y)]:02}')
                else : line.append('__')
            print(*line, sep=' ')
    else : return spread

def debug_run_path(controller, cursor, fork_map, tile, cmd = '', r = '') :
        """ position in debug line:
        1           tile                      -> tile from which dir_ starts to browse 
        2           cursor['idx']             -> index in dir_
        3           block/end_path            -> when blocking or end_path is true
        4 fork_map['fork']/fork_map['max']    -> main information on the situation in fork_map
        '_' if nothing
        OPTION : if cmd = 'cursor','fork_map', 'controller' print one or several contain
        """
        show = (max([controller['blocking'], controller['end_path']]),
                controller['blocking'],
                controller['end_path']) 
        fork_map_situation = [str(fork) + '/' + str(max_)
                              for fork in list(fork_map['fork'].values())
                              for max_ in list(fork_map['max'].values()) ]
        space = ' ' * 25 if tile[1] % 2 != 0 else '' # just to see more tile changing
        r += (space + str(tile)) * show[0]
        r += (' ' + str(cursor['idx'])) * show[0]
        r += (' ' + ('block')) * show[1]
        r += (' ' + ('end_path')) * show[2]
        r += (' ' + str(*fork_map_situation if fork_map_situation else '_'))* show[0]
        r += (' ' + str(controller['stop'])) * show[0]
        if  'fork_map' in cmd : r += (' ' + str(fork_map)) * show[0]
        if 'cursor' in cmd : r += (' ' + str(cursor)) * show[0]
        if 'controller' in cmd : r += (' ' + str(controller))* show[0]
        if r : print(r)
        else : pass

def debug_built_path_process(game_map, parameters, num_test) : # nouveau
    import matplotlib.pyplot as plt
    import statistics as stat
    current_path = config_play_map(position = game_map['brows'])
    count = 0
    path_length, path_value, process_time, swing_turn, path_spread = [], [], [], [], []
    while count != num_test :
        rand_path, value, turn, time = path_map(current_path, game_map, parameters)
        length = len(rand_path)
        spread = debug_path(rand_path)
        path_length.append(length)
        path_value.append(value)
        process_time.append(time)
        swing_turn.append(turn)
        path_spread.append(spread)
        count += 1

    print(*[(f' length : {round(stat.mean(path_length),2) , round(stat.pstdev(path_length),2)}' ),
            (f' value  : {round(stat.mean(path_value),2)  , round(stat.pstdev(path_value),2)}'  ),
            (f' time   : {round(stat.mean(process_time),2), round(stat.pstdev(process_time),2)}'),
            (f' turn   : {round(stat.mean(swing_turn),2)  , round(stat.pstdev(swing_turn),2)}'  ),
            (f' spread : {round(stat.mean(path_spread),2) , round(stat.pstdev(path_spread),2)}' ),
           ], sep = '\n'
         )
    plt.plot(path_length)
    plt.plot(path_value)
    plt.plot(process_time)
    plt.plot(swing_turn)
    plt.plot(path_spread)

# tools

from random import choice
from random import choices
from random import randrange # nouveau ?
from random import sample
from time import perf_counter
import math
import copy

def add_tuple (tuple_1, tuple_2) :
    return tuple_1[0] + tuple_2[0], tuple_1[1] + tuple_2[1]

def normal_law(x,s2,mu): # nouveau
    sigma = math.sqrt(s2)     
    return (1 / (sigma * math.sqrt(2 * math.pi))) * math.exp((-1 / 2) * (((x - mu)/sigma) ** 2))

def dir_tile_converter(direction_path, start_tile=(0,0)) :
    tile_path = [start_tile]
    current_tile = start_tile
    for current_direction in direction_path :
        current_tile = add_tuple(current_tile, current_direction[0])
        tile_path.append(current_tile)
    return tile_path

# game_map

def config_game_map(parameters) : # nouveau
    if parameters['test_mod'] == False :
        width, height, my_id = [int(i) for i in input().split()]
        size = width if width == height else 'problem'
    else : 
        size = parameters['size_map']
        weights = [normal_law(i,s2=2,mu=4) for i in range(11)] 
        num_island = choices([i for i in range(11)], weights)
        tiles = [(x,y) for x in range(size) for y in range(size)]
        print(num_island)
        island = sample(tiles, *num_island)
        brows = [xy for xy in tiles if xy not in island]
        print(island)
    return {'island' : island, 'size' : size, 'brows' : brows}

def config_play_map(play_map  = None,
                    dir_path  = [], 
                    tile_path = [], 
                    position  = [],
                    sector    = {'in' : {}, 'out' : {}, 'tiles' : {}} ### nouveau : avant : config_dir_map
                   ) :
    if play_map :
        if not dir_path  : dir_path  = play_map['dir']
        if not tile_path : tile_path = play_map['last_tiles'] 
        if not position  : position  = play_map['position']
        if not sector    : sector    = play_map['sector'] ### sector est bien maj en bloc ???
    play_map = {
                'dir'          : dir_path , 
                'last_tiles'   : tile_path,
                'position'     : position,
                'max'          : (
                                  sum([xy[0][0] for xy in dir_path if len(xy) == 1]) ,
                                  sum([xy[0][1] for xy in dir_path if len(xy) == 1]) 
                                 ), 
                'length'       : len(dir_path),
                'fork'         : [idx for idx in range(len(dir_path)) if len(dir_path[idx]) != 1],
                'sector'       : sector
               }
    if play_map['position'] not in play_map['last_tiles'] : play_map['last_tiles'].append(play_map['position'])
    return play_map

# run path : map

def off_side_max(max_, size) :
    e_w, n_s = max_
    return (e_w not in range(0,size) or n_s not in range(0,size))

def off_side_tile (tile, size) :
    x,y = tile
    return (x not in range(0,size) or y not in range(0,size)) # 1 c'est pas logique

def sector (xy) :
    sector = {'1': [ 0, 5, 0, 5], '2' : [ 0, 5, 5,10], '3' : [ 0, 5,10,15],
              '4': [ 5,10, 0, 5], '5' : [ 5,10, 5,10], '6' : [ 5,10,10,15],
              '7': [10,15, 0, 5], '8' : [10,15, 5,10], '9' : [10,15,10,15]}
    for i in '123456789' :
        if sector[i][0] <= xy[0] < sector[i][1] and sector[i][2] <= xy[1] < sector[i][3] : 
            return int(i)

def dir_converter(key) :
    # NB : can't put list of tuple as key
    dir_dic = { (-1, 0) : 'W', 'W' : [(-1, 0)],
                ( 1, 0) : 'E', 'E' : [( 1, 0)],
                ( 0,-1) : 'N', 'N' : [( 0,-1)],
                ( 0, 1) : 'S', 'S' : [( 0, 1)],
                'silence' : list(set([(x,0) for x in range(-4,5)] + [(0,y) for y in range(-4,5)])) }
    return dir_dic[key]

# start_tile

def random_path(initial_play_map, game_map, parameters) : # nouveau
    direction = [ [(1,0)], [(-1,0)], [(0,1)], [(0,-1)] ]
    while True :
        temp_direction = [(0,0)]
        first_direction = None
        counter = 0
        current_direction_path = copy.deepcopy(initial_play_map['dir'])
        current_tile = choice(initial_play_map['position'])
        current_tile_path = (
                              copy.deepcopy(initial_play_map['last_tiles']) 
                              if parameters['status'] != 'me'
                              else dir_tile_converter(initial_play_map['dir'], current_tile)
                            )
        while True :
            temp_direction = choice(direction)
            temp_tile = add_tuple(current_tile,temp_direction[0])
            if temp_tile not in current_tile_path and blocking(temp_tile, game_map) == False :
                if first_direction == None : first_direction = temp_direction
                current_direction_path.append(temp_direction)
                current_tile = temp_tile
                current_tile_path.append(current_tile)
                counter = 0
                if len(current_direction_path) == parameters['max_length'] : 
                    return current_direction_path, first_direction
            else :
                counter += 1
                if counter > 6 and first_direction != None : 
                    return current_direction_path, first_direction
                elif counter > 6 : break
        

# game_loop : orders

def torpedo_area(center, game_map) :
    ref_position = center
    current_position = ref_position
    direction = [ [(1,0)], [(-1,0)], [(0,1)], [(0,-1)] ]
    torpedo_area = []
    torpedo_range = 4
    range_, try_, max_try = 0, 0, torpedo_range**6
    while True :
        try_ += 1
        range_ += 1
        current_direction = choice(direction)
        current_position = add_tuple(current_position,current_direction[0])
        if blocking(current_position, game_map) :
            current_position = ref_position
            range_ = 0
            continue
        if current_position not in torpedo_area and current_position != ref_position :
            torpedo_area.append(current_position)
            current_position = ref_position
            try_ = 0
            range_ = 0
        if range_ == torpedo_range : 
            current_position = ref_position
            range_ = 0
        if try_ == max_try or len(torpedo_area) == 40 : return torpedo_area

def manage_order(index, order, play_map, game_map, sonar_result) :
    message_order = [cursor.split() for cursor in order.split('|')]
    for order_cursor in message_order :
        if order_cursor[0] == 'MOVE' : play_map['dir'].append( dir_converter(order_cursor[1]) )
        elif order_cursor[0] == 'SILENCE' : play_map['dir'].append(dir_converter('silence'))
        elif (order_cursor[0] == 'SURFACE' or order_cursor[0] == 'SONAR'
             ) : play_map['sector']['in'][index] = order_cursor[1]
        elif order_cursor[0] == 'TORPEDO' :
            shoot_tile = order_cursor[1], order_cursor[2]
            play_map['sector']['tiles'][index] = torpedo_area(shoot_tile, game_map)
        if 'NA' not in sonar_result : 
            if   sonar_result[1] == 'Y' : play_map['sector']['in'][index - 1] = sonar_result[0]
            elif sonar_result[1] == 'N' : play_map['sector']['out'][index - 1] = sonar_result[0]
    return config_play_map(play_map, dir_path = play_map['dir'], sector = play_map['sector']) ### A REVOIR

# run path : cursor

def initial_cursor(play_map, fork_map, tile) :
    # 'dir' : current position in play_map
    # 'idx' : current index in play_map
    # 'fork' : least embranchement '' if no fork
    # 'tile' : current tile on map
    init_cursor = {'dir' : (), 'idx' : 0, 'tile' : () }
    init_cursor['dir'] = ( 
                          play_map['dir'][0][fork_map['fork'][0]-1] 
                          if fork_map['fork'].get(0) != None
                          else play_map['dir'][0][0]
                         )
    init_cursor['tile'] = add_tuple(tile, init_cursor['dir'])
    return init_cursor

def update_cursor (cursor, play_map, fork_map) :
    cursor['idx'] += 1
    branch_index = ( 
                    fork_map['fork'][cursor['idx']] 
                    if fork_map['fork'].get(cursor['idx']) != None
                    else 0 
                   )
    cursor['dir'] = play_map['dir'][ cursor['idx'] ] [branch_index]
    cursor['tile'] = add_tuple(cursor['tile'], cursor['dir'])
    return cursor

# run_path : fork_map
            
def config_fork_map (play_map) :
    # how fork_map is built :
    fork_map = {'fork' : {}, 'max' : {}, 'fork-index': {}, 'index-fork' : {}}
    index = 0
    for fork in play_map['fork'] :
        fork_map['fork'][fork] = 0
        fork_map['max'][fork] = len(play_map['dir'][fork])
        fork_map['fork-index'][fork] = index
        fork_map['index-fork'][index] = fork
        index += 1
    return fork_map

def del_fork_map (fork_map, fork) :
    index = fork_map['fork-index'][fork] 
    for cursor in ['fork', 'max', 'fork-index'] : del fork_map[cursor][fork]
    del fork_map['index-fork'][index]
    return fork_map

def update_fork_map(fork, fork_map): 
    fork_map['fork'][fork] += 1
    while fork_map['fork'][fork] > fork_map['max'][fork] :
        index = fork_map['fork-index'][fork]
        index -= 1 if index - 1 >= 0 else 0
        fork_map = del_fork_map(fork_map, fork)
        try :
            fork = fork_map['index-fork'][index]
            fork_map['fork'][fork] += 1    
        except KeyError : break
    return fork_map

# run_path : controller

def blocking(tile, game_map, sector = {'in' : {}, 'out' : {}, 'tiles' : {}}, index = None) : # revoir : sector_map
    blocking = (    True 
                    if tile in game_map['island'] 
                    or off_side_tile(tile, game_map['size']) 
                    or ( sector['in'].get(index) != None 
                            and sector['in'].get(index) != sector(tile) )
                    or ( sector['out'].get(index) != None
                         and tile not in sector['out'].get(index) )
                    else False
                )
    return blocking

def stop(fork_map) :
    if len(fork_map['fork'].keys()) != len(fork_map['max'].keys()) : 
        raise ValueError('fork_map')
    if (len(fork_map['fork'].keys()) == 1 and 
        list(fork_map['fork'].values()) == list(fork_map['max'].values())) :
        return True
    else : return False
    
# game reading 

def length_value(length, max_length) : # nouveau
    coef = (math.pi / 2) / max_length
    return round( math.sin(length*coef), 2)

def scatter_value(possible_path) : # nouveau
    next_tiles = [(x,y) for x in range(-1,2) for y in range(-1,2) if (x,y) != (0,0)]
    scatter = 0
    sector_list = []
    for key in possible_path.keys() :
        sector_list.append(sector(key))
        if possible_path[key] == 1 :
            cursor_list = [add_tuple(key, tiles) for tiles in next_tiles]
            count = 0
            for cursor in cursor_list :
                try : possible_path[cursor]
                except KeyError : continue
                if possible_path[cursor] == 1 : count += 1
            scatter += (1 - (0.1 * count)) if count >= 2 else 1
    nb_sector = len(set(sector_list))
    scatter = round ( scatter * math.log(nb_sector + 1, 10), 2)
    return scatter
            
# main engine

def path_map(play_map, game_map, parameters) : # nouveau
    "debut de fonction (app)"
    best_value, value, try_, swing_turn, swing_time = 0, 0, 0, 0, 0
    possible_path = []
    start_time, time = perf_counter(), 0
    max_time = parameters['start_time'] if parameters['status'] == 'start' else parameters['turn_time']
    while time < max_time :
        ratio = False
        while ratio == False :
            current_random_dir_map, current_next_direction = random_path(play_map, game_map, parameters) ###
            length_ratio = len(current_random_dir_map) / parameters['max_length']
            time = perf_counter() - start_time
            time_ratio = time / max_time
            ratio = length_ratio > time_ratio  
            if time >= max_time : break
        current_random_play_map = config_play_map(play_map, dir_path = current_random_dir_map)
        current_possible_path   = run_map( game_map, current_random_play_map)
        value = round( scatter_value(current_possible_path) * length_value(current_random_play_map['length'],parameters['max_length']), 2)
        if value > best_value :
            swing_turn = try_
            swing_time = perf_counter() - start_time
            best_value = value
            possible_path  = [current_possible_path]
            random_play_map = [current_random_play_map]
            next_direction = [current_next_direction]
        elif value == best_value :
            possible_path.append(current_possible_path)
            random_play_map.append(current_random_play_map)
            next_direction.append(current_next_direction)
        time = perf_counter() - start_time
        try_ += 1
    
    idx = randrange(len(possible_path))
    possible_path = possible_path[idx]
    random_play_map = random_play_map[idx]
    next_direction = next_direction[idx]
    # debug_map(possible_path, game_map)
    # debug_path(random_play_map['dir'],show_path=True)
    ###
    if   parameters['test_mod'] == False and parameters['status'] == 'start' : return possible_path
    elif parameters['test_mod'] == False and parameters['status'] == 'me' : return possible_path, next_direction  
    else : return random_play_map['dir'], best_value, swing_turn, swing_time
    ###

def run_map(game_map, play_map, init_fork_map ={'fork':{}}, command ='gameloop') :
    # integrer dans un run map un filtre ('max_NS','max_EW')
    possible_path = {}
    for tile in game_map['brows'] :
        #if off_side_max( add_tuple(tile, play_map['max']), game_map['size']) : continue
        fork_map = copy.deepcopy(init_fork_map)
        possible_path[tile] = run_path(tile, game_map, play_map, fork_map)     
    # if command == 'gameloop' : show_map(possible_path, game_map)
    return possible_path

def run_path(tile, game_map, play_map, fork_map, start=True) :
    cursor = initial_cursor(play_map, fork_map, tile)
    controller = {'blocking' : False,  'end_path' : False, 'stop' : True}
    possible_path = 0 # possible path for this tile
    
    while True :
        
        "A : embranchement : "
        if fork_map['fork'].get(cursor['idx']) != None :
            fork_map = update_fork_map(cursor['idx'], fork_map)
            controller['stop'] = stop(fork_map)
        "B : obstacle : " 
        controller['blocking'] = blocking(cursor['tile'], game_map, play_map['sector'], cursor['idx'])
        "C : bout de path : " 
        controller['end_path'] = True if cursor['idx'] == play_map['length'] - 1 else False

        # debug_run_path(controller, cursor, fork_map, tile) # DEBUG MOD
            
        if controller['end_path'] == True and controller['blocking'] == False : possible_path += 1
        
        if controller['stop'] == False :
            if controller['blocking'] == True or controller['end_path'] == True :
                cursor = initial_cursor(play_map, fork_map, tile)
                continue
        else :
            if controller['blocking'] == True or controller['end_path'] == True :
                return possible_path
        
        cursor = update_cursor(cursor, play_map, fork_map)

# game

def start(game_map, parameters) : # nouveau
    start_play_map = config_play_map(position = game_map['brows'])
    possible_path = path_map(start_play_map,game_map, parameters)
    start_tile = choice( [key for key in possible_path if possible_path[key] > 0] )
    return start_tile

def game_loop(game_map, parameters) : # nouveau
    lap = 0
    sonar_result = 'NA'
    his_play_map = config_play_map()
    my_play_map  = config_play_map()
    
    while True :
        """
        x, y, my_life, opp_life, torpedo_cooldown, sonar_cooldown, silence_cooldown, mine_cooldown = [int(i) for i in input().split()]
        my_position = (x,y)
        sonar_result = sonar_result, input()
        """
        
        # random_path _> play_map['current_tile] continuer
        
        #his_play_map = manage_order(lap, input(), his_play_map, game_map, sonar_result)

        #direction = dir_converter( my_play_map['dir'][lap][0] )

        lap += 1
        return 
        
def main(): ### nouveau
    parameters = {
                    'test_mod'   : True,
                    'status'     : 'start',
                    'start_time' : 0.8, 
                    'turn_time'  : 0.4, 
                    'ref_length' : 16, 
                    'max_length' : 24,
                    'size_map'   : 15
                 }
    game_map = config_game_map(parameters)
    debug_built_path_process(game_map, parameters, 30)
    start_time = perf_counter()
    start_tile = start(game_map, parameters) 
    # print(*start_tile, sep = ' ')
    game_loop(game_map, parameters)  

if __name__ == '__main__' : main()
