# Library

from random import choice
from random import choices
from random import randrange # nouveau ?
from random import sample
from time import perf_counter
import statistics as stat
import math
import copy

# declaring
global test_mode
test_mod = True


def config_constant() :
    global constant
    constant = {    
                'size_map'   : 15,        # default size of when we are in test mod
                'start_time' : 0.8,       # how much time we can run next_tiles() at start
                'turn_time'  : 0.4,       # how much time we can run next_tiles() in game_loop
                'stacking'   : 3 + 1,     # how many random_dir we keep in next_tiles(). + 1 because python
                'max_length' : 24,        # max length of play_map['dir'] in next_tiles()
                'marg_error'    : 3/100,     # margin of error when choosing the best value in next_tiles()
                'num_test'   : 30         # number of tests in debug_map_process
                }

def config_game_map() : # nouveau
    global game_map
    """
    ReprÃ©sente the playground. It's a dictionnary containning three keys  :
    island : list of island tiles
    size : one integer which is the lenghth of the sides of the square
    brows : free tiles where the submarine can move
    """
    if test_mod == False :
        width, height, my_id = [int(i) for i in input().split()]
        size = width if width == height else 'problem'
    else : 
        my_id = choice([0,1])
        size = constant['size_map']
        weights = [normal_law(i,s2=2,mu=4) for i in range(11)] 
        num_island = choices([i for i in range(11)], weights)
        tiles = [(x,y) for x in range(size) for y in range(size)]
        island = sample(tiles, *num_island)
        brows = [xy for xy in tiles if xy not in island]
    game_map = {'island' : island, 'size' : size, 'brows' : brows, 'IA start' : bool(my_id)}

# debug

def debug_map(content) :
    # give graphics overview of the value of each tiles, content is a dic with tuple (x,y) as key
    for y in range(game_map['size']):
        line = []
        for x in range(game_map['size']):
            try : line.append(f'{content[x,y]:02}')
            except KeyError : line.append('XX')
        print(*line, sep=' ')   

def debug_path(path, show_path = False):
    tile_cursor = (0,0)
    path_cursor = [tile_cursor]
    for direction in path :
        tile_cursor = add_tuple(tile_cursor, direction[0])
        path_cursor.append( tile_cursor)
    
    min_x = min([xy[0] for xy in path_cursor])
    min_y = min([xy[1] for xy in path_cursor])
    correction = -min_x, -min_y
    path_cursor = list(map(lambda xy : add_tuple(xy, correction),path_cursor))
    path_cursor = { key : value for value,key in enumerate(path_cursor) }
    max_x = max([xy[0] for xy in path_cursor])
    max_y = max([xy[1] for xy in path_cursor])
    spread = round( abs(max_x - min_x) * abs(max_y - min_y) / (game_map['size']**2) , 2)
    
    if show_path == True :
        for y in range(max_y + 1) :
            line = []
            for x in range(max_x + 1) :
                if (x,y) in path_cursor :
                    line.append(f'{path_cursor[(x,y)]:02}')
                else : line.append('__')
            print(*line, sep=' ')
    else : return spread

def debug_run_path(controller, cursor, fork_map, tile, cmd = '', r = '') :
        """ position in debug line:
        1           tile                      -> tile from which dir_ starts to browse 
        2           cursor['idx']             -> index in dir_
        3           block/end_path            -> when blocking or end_path is true
        4 fork_map['fork']/fork_map['max']    -> main information on the situation in fork_map
        '_' if nothing
        OPTION : if cmd = 'cursor','fork_map', 'controller' print one or several contain
        """
        show = (max([controller['blocking'], controller['end_path']]),
                controller['blocking'],
                controller['end_path']) 
        fork_map_situation = [str(fork) + '/' + str(max_)
                              for fork in list(fork_map['fork'].values())
                              for max_ in list(fork_map['max'].values()) ]
        space = ' ' * 25 if tile[1] % 2 != 0 else '' # just to see more tile changing
        r += (space + str(tile)) * show[0]
        r += (' ' + str(cursor['idx'])) * show[0]
        r += (' ' + ('block')) * show[1]
        r += (' ' + ('end_path')) * show[2]
        r += (' ' + str(*fork_map_situation if fork_map_situation else '_'))* show[0]
        r += (' ' + str(controller['stop'])) * show[0]
        if  'fork_map' in cmd : r += (' ' + str(fork_map)) * show[0]
        if 'cursor' in cmd : r += (' ' + str(cursor)) * show[0]
        if 'controller' in cmd : r += (' ' + str(controller))* show[0]
        if r : print(r)
        else : pass

def debug_built_path_process() : # nouveau
    import matplotlib.pyplot as plt
    current_path = config_play_map(position = game_map['brows'])
    count = 0
    indicator = ['path_length', 'path_value', 'process_time', 'swing_turn', 'path_spread']
    label = ['length', 'value', 'time', 'turn', 'spread']
    label = dict(zip(indicator, label))
    metric = {key : [] for key in indicator}
    while count != constant['num_test'] :
        rand_path, value, turn, time = next_tile(current_path, status = 'debug_process')
        metric['path_spread'].append(debug_path(rand_path))
        metric['path_length'].append(len(rand_path))
        metric['path_value'].append(value)
        metric['process_time'].append(time)
        metric['swing_turn'].append(turn)
        count += 1
    for key in list(metric.key()) : print(f'{label[key]} : {round(stat.mean(metric[key]), 2)}')
    turn = list(range(constant['num_test']))
    fig, ax1 = plt.subplots(layout='constrained')
    ax1.plot(turn, metric['path_value'], color='tab:red')
    ax1.plot(turn, metric['process_time'], color='tab:orange')
    ax1.tick_params(axis='y', labelcolor='tab:red')
    
    ax2 = ax1.twinx()
    ax2.plot(turn, metric['path_length'], color='tab:blue')
    ax2.plot(turn, metric['swing_turn'], color='tab:cyan')
    ax2.plot(turn, metric['path_spread'], color='tab:purple')
    ax2.tick_params(axis='y', labelcolor='tab:blue')
    plt.show()

# tools

def add_tuple (tuple_1, tuple_2) :
    return tuple_1[0] + tuple_2[0], tuple_1[1] + tuple_2[1]

def normal_law(x,s2,mu): # nouveau
    sigma = math.sqrt(s2)     
    return (1 / (sigma * math.sqrt(2 * math.pi))) * math.exp((-1 / 2) * (((x - mu)/sigma) ** 2))

def off_side_max(max_) :
    size = game_map['size']
    e_w, n_s = max_
    return (e_w not in range(0,size) or n_s not in range(0,size))

def off_side_tile (tile) :
    size = game_map['size']
    x,y = tile
    return (x not in range(0,size) or y not in range(0,size)) # 1 c'est pas logique

def sector (xy) :
    sector = {'1': [ 0, 5, 0, 5], '2' : [ 0, 5, 5,10], '3' : [ 0, 5,10,15],
              '4': [ 5,10, 0, 5], '5' : [ 5,10, 5,10], '6' : [ 5,10,10,15],
              '7': [10,15, 0, 5], '8' : [10,15, 5,10], '9' : [10,15,10,15]}
    for i in '123456789' :
        if sector[i][0] <= xy[0] < sector[i][1] and sector[i][2] <= xy[1] < sector[i][3] : 
            return int(i)

def dir_tile_converter(direction_path, start_tile=(0,0)) :
    tile_path = [start_tile]
    current_tile = start_tile
    for current_direction in direction_path :
        current_tile = add_tuple(current_tile, current_direction[0])
        tile_path.append(current_tile)
    return tile_path

def dir_converter(key) :
    # NB : can't put list of tuple as key
    dir_dic = { (-1, 0) : 'W', 'W' : [(-1, 0)],
                ( 1, 0) : 'E', 'E' : [( 1, 0)],
                ( 0,-1) : 'N', 'N' : [( 0,-1)],
                ( 0, 1) : 'S', 'S' : [( 0, 1)],
                'silence' : list(set([(x,0) for x in range(-4,5)] + [(0,y) for y in range(-4,5)])) }
    return dir_dic[key]

def blocking(tile, sector = {'in' : {}, 'out' : {}, 'tiles' : {}}, index = None) : # revoir : sector_map
    blocking = (    True 
                    if tile in game_map['island'] 
                    or off_side_tile(tile) 
                    or ( sector['in'].get(index) != None 
                            and sector['in'].get(index) != sector(tile) )
                    or ( sector['out'].get(index) != None
                         and tile not in sector['out'].get(index) )
                    else False
                )
    return blocking

def stop(fork_map) :
    if len(fork_map['fork'].keys()) != len(fork_map['max'].keys()) : 
        raise ValueError('fork_map')
    if (len(fork_map['fork'].keys()) == 1 and 
        list(fork_map['fork'].values()) == list(fork_map['max'].values())) :
        return True
    else : return False

# map

def config_play_map(play_map  = None,
                    dir_path  = [], 
                    next_dir  = [],
                    next_tile = [],
                    next_paths = [],
                    tile_path = [], 
                    position  = [],
                    sector    = {'in' : {}, 'out' : {}, 'tiles' : {}} ### nouveau : avant : config_dir_map
                   ) :
    """
    Configure play_map wich is the most important (and almost unique) place where are compute player information.
    Both players have their own play_map which contains all the information about the player's game. 
    It is dictionnary containing several types of variable and sequences. 
    
    All lists are ordered. Which means that all the information appeared at the same index on each 
    list corresponds to the same lap. 
    
    'dir' :        List of list of tuples representing directions previously followed by the submarine.
                   [[(0,-1)],[(0,-1)],[(1,0)]] is 'North, North, West'. Sometimes, when the opposit players plays 
                   'Silence' there is several tuples the list of list : [[(0,1)],[(0,1),(0,-1)]]
                   See 'dir_converter' function for all details.
    
    'next_dir' :   Next direction calculated by 'next_tile' function not yet in 'play_map['dir']'. 
    
    'next_tile' :   Next tile calculated by 'next_tile' function not yet in 'play_map[last_tiles]'.
    
    'next_paths' : 'Next_tiles' function have few time to find Ã  goog next tile for the submarine. Keeping
                   the best next_paths of the previus search in 'next_tiles' function ensure us to have a
                   good next direction.
                   
    'max_length_next_path' :
                   Maximum length of next_path earn in next_tile function. Give idea of the space 
                   that have the submarine to move.
                  
    'max' :        Tuple representing respectively beetween max West and max East and the max North and 
                   the max South followed by 'dir'. [(0,-1),(0,-1),(1,0)] -> play_map['max'] = (1,2) 
                   because there are two movement in est-west and one in north-south.
                  
    'length' :     Length of 'dir'. avoid two employ len(play_map['dir']) several times in the game.
    
    'fork'   :     The list of index of the list of list of 'dir' where there is more than one tuples :
                   [[(0,1)],[(0,1),(0,-1)],[(0,1)],[(0,1),(0,-1)]] give play_map['fork'] = [1,3].
                   Use especially in 'run_path' function.
                  
    'sector' :     Dictionnary of three dictionnaries built in the same way. 'In' contains sector where 
                   submarine must be at a given lap. 'in' : { 0 : 1} mean 'the submarine must be in sector 
                   1 at lap 0' wich correspond also to play_map['dir'][0] and play_map['last_tiles'][0] 
                   wich are the index 0 of 'dir' list and 'last_tiles' list.
                  
    'position' :  List of tuple (x,y) representing the current position of (x,y) only one tuple for 
                  my_play_map and many position (almost at the beginning) for his_play_map.
    
    'last_tiles : List of tuples representing tiles previously traveled by the submarine'.
                  [(1,2),(1,1),(1,1),(0,0)] when following the 'dir' exemple above.
    """
    if play_map :
        if not dir_path   : dir_path   = play_map['dir']
        if not next_dir   : next_dir   = play_map['next_dir']
        if not next_tile  : next_tile  = play_map['next_tile']
        if not next_paths : next_paths = play_map['next_paths'] 
        if not tile_path  : tile_path  = play_map['last_tiles'] 
        if not position   : position   = play_map['position']
        if not sector     : sector     = play_map['sector'] ### sector est bien maj en bloc ???

    play_map = {
                'dir'          : dir_path , 
                'next_dir'     : next_dir ,
                'next_tile'    : next_tile,
                'next_paths'   : next_paths,
                'max'          : (
                                  sum([xy[0][0] for xy in dir_path if len(xy) == 1]) ,
                                  sum([xy[0][1] for xy in dir_path if len(xy) == 1]) 
                                 ), 
                'length'       : len(dir_path),
                'fork'         : [idx for idx in range(len(dir_path)) if len(dir_path[idx]) != 1],
                'sector'       : sector,
                'position'     : position,
                'last_tiles'   : tile_path
               }
    if play_map['position'] not in play_map['last_tiles'] : play_map['last_tiles'].append(play_map['position'])
    if not play_map['position'] : play_map['position'] = game_map['brows']
    return play_map

def update_play_map(play_map, game):
    """
    verifie :
        play_map[position] == game['my_position']
        play_map[next_tile] != play_map[position]
        play_map[position] NOT in play_map[last_tiles]
    supprime premier/dernier (verrifier) play_map[dir]
    ajout play_map[position] Ã  play_map[last_tiles]
    MAJ play_map[length]
    """

def config_target(my_play_map, his_play_map, status = 'game loop') :
    'where are informations about balance of power beetween me and he'
    if status == 'game loop' :
        my_scatter   = run_map(my_play_map)
        my_position  = list(filter(lambda key : my_scatter[key] == 1, my_scatter))
        his_scatter  = run_map(his_play_map)
        his_position = list(filter(lambda key : his_scatter[key] == 1, his_scatter))
        target = {
                  'my_scatter'  : my_scatter,
                  'my_position' : my_position,
                  'his_scatter' : his_scatter,
                  'his_postion' : his_position,
                  'coef'        : round( my_position / his_position, 2),
                 }
    else : target = {'coef' : 0}
    return target

# next_tile

def evaluate_dir_map(play_map, target, current_random_dir_path) :
    all_random_dir_map = ( play_map['dir'].append(current_random_dir_path) 
                           if play_map['dir'] 
                           else current_random_dir_path )
    current_random_play_map = config_play_map(play_map, dir_path = all_random_dir_map)
    current_possible_path   = run_map(current_random_play_map)
    
    hiding_value = scatter(current_possible_path, current_random_play_map['length'])
    hunting_value = hunting()
    
    value = round( (1-target['coef']) * hiding_value + target['coef'] * hunting_value, 2)
    
    return value, current_possible_path 

def random_path(initial_play_map) : # nouveau
    direction = [ [(1,0)], [(-1,0)], [(0,1)], [(0,-1)] ]
    while True :
        temp_direction = [(0,0)]
        first_direction = None
        counter = 0
        current_direction_path = []
        current_tile = choice(initial_play_map['position'])
        current_tile_path = (
                              copy.deepcopy(initial_play_map['last_tiles']) 
                              if initial_play_map['last_tiles']
                              else dir_tile_converter(initial_play_map['dir'], current_tile)
                            )
        while True :
            temp_direction = choice(direction)
            temp_tile = add_tuple(current_tile,temp_direction[0])
            if temp_tile not in current_tile_path and blocking(temp_tile) == False :
                if first_direction == None : first_direction = temp_direction
                current_direction_path.append(temp_direction)
                current_tile = temp_tile
                current_tile_path.append(current_tile)
                counter = 0
                if len(current_direction_path) == constant['max_length'] : 
                    return current_direction_path, first_direction
            else :
                counter += 1
                if counter > 6 :
                    if first_direction != None :
                        return current_direction_path, first_direction
                    else : break

def best_random_path(play_map, target, status) :
    best_value, try_, start_time, time = 0, 0, perf_counter(), 0
    max_time = constant['start_time'] if status == 'start' else constant['turn_time']
    max_length, min_value = 0, 0
    best_values, possible_path, dir_path, next_direction = [], [], [], [], 
    while time < max_time :
        ratio = False
        while ratio == False :
            current_random_dir_path, current_next_direction = random_path(play_map) ###
            current_length = len(current_random_dir_path)
            length_ratio = current_length / constant['max_length']
            time = perf_counter() - start_time
            time_ratio = time / max_time
            ratio = length_ratio > time_ratio  
            if time >= max_time : break
        
        value, current_possible_path = evaluate_dir_map(play_map, target, current_random_dir_path)
        if test_mod :
            if value > best_value :
                best_value = value
                time = perf_counter() - start_time
                metrics = {'dir_path' : current_random_dir_path, 'best_value' : value,
                           'swing_turn' : try_, 'swing_time' : time}

        if current_length > max_length : max_length = current_length
        if len(best_values) < constant['stacking'] :
            best_values.append(value)
            possible_path.append(current_possible_path)
            dir_path.append(current_random_dir_path)
            next_direction.append(current_next_direction)
            continue
        if value <= min_value : continue
        for idx in range(constant['stacking']) :
            if best_values[idx] < value :
                best_values.insert(idx, value)
                possible_path.insert(idx, current_possible_path)
                dir_path.insert(idx, current_random_dir_path)
                next_direction.insert(idx, current_next_direction)
                best_values.pop(-1)
                possible_path.pop(-1)
                dir_path.pop(-1)
                next_direction.pop(-1)
                min_value = best_values[-1]
                # arranger Ã§a quand on aurra du temps
        time = perf_counter() - start_time
        try_ += 1
    return possible_path, dir_path, next_direction, max_length, metrics

def next_tile(play_map, target, status) : # nouveau

    possible_path, dir_path, next_direction, max_length, metrics = best_random_path(play_map, target, status)
    
    play_map['max_length_next_path'] = max_length
    play_map['best_paths'] = dir_path
    idx = randrange(constant['stacking'])
    play_map['next_direction'] = next_direction[idx]
    play_map['next_tile'] = ( add_tuple(*play_map['position'], next_direction) 
                             if len(play_map['position']) == 1
                             else False
                           )
    if status == 'debug_process' : dir_path, *list(metrics.values())
    if test_mod == False :
        if status == 'start' : 
            play_map['position'] = choice( list(filter(lambda key : possible_path[key] == 1, possible_path)) )
        return play_map
    else : 
        dir_path = dir_path[idx]
        possible_path = possible_path[idx]
        debug_map(possible_path)
        debug_path(dir_path, show_path=True)
        return play_map

# game_loop : orders

def torpedo_area(center) :
    ref_position = center
    current_position = ref_position
    direction = [ [(1,0)], [(-1,0)], [(0,1)], [(0,-1)] ]
    torpedo_area = []
    torpedo_range = 4
    range_, try_, max_try = 0, 0, torpedo_range**6
    while True :
        try_ += 1
        range_ += 1
        current_direction = choice(direction)
        current_position = add_tuple(current_position,current_direction[0])
        if blocking(current_position) :
            current_position = ref_position
            range_ = 0
            continue
        if current_position not in torpedo_area and current_position != ref_position :
            torpedo_area.append(current_position)
            current_position = ref_position
            try_ = 0
            range_ = 0
        if range_ == torpedo_range : 
            current_position = ref_position
            range_ = 0
        if try_ == max_try or len(torpedo_area) == 40 : return torpedo_area

# cursor

def initial_cursor(play_map, fork_map, tile) :
    # 'dir' : current position in play_map
    # 'idx' : current index in play_map
    # 'fork' : least embranchement '' if no fork
    # 'tile' : current tile on map
    init_cursor = {'dir' : (), 'idx' : 0, 'tile' : () }
    init_cursor['dir'] = ( 
                          play_map['dir'][0][fork_map['fork'][0]-1] 
                          if fork_map['fork'].get(0) != None
                          else play_map['dir'][0][0]
                         )
    init_cursor['tile'] = add_tuple(tile, init_cursor['dir'])
    return init_cursor

def update_cursor (cursor, play_map, fork_map) :
    cursor['idx'] += 1
    branch_index = ( 
                    fork_map['fork'][cursor['idx']] 
                    if fork_map['fork'].get(cursor['idx']) != None
                    else 0 
                   )
    cursor['dir'] = play_map['dir'][ cursor['idx'] ] [branch_index]
    cursor['tile'] = add_tuple(cursor['tile'], cursor['dir'])
    return cursor

# fork_map
            
def config_fork_map (play_map) :
    # how fork_map is built :
    fork_map = {'fork' : {}, 'max' : {}, 'fork-index': {}, 'index-fork' : {}}
    index = 0
    for fork in play_map['fork'] :
        fork_map['fork'][fork] = 0
        fork_map['max'][fork] = len(play_map['dir'][fork])
        fork_map['fork-index'][fork] = index
        fork_map['index-fork'][index] = fork
        index += 1
    return fork_map

def del_fork_map (fork_map, fork) :
    index = fork_map['fork-index'][fork] 
    for cursor in ['fork', 'max', 'fork-index'] : del fork_map[cursor][fork]
    del fork_map['index-fork'][index]
    return fork_map

def update_fork_map(fork, fork_map): 
    fork_map['fork'][fork] += 1
    while fork_map['fork'][fork] > fork_map['max'][fork] :
        index = fork_map['fork-index'][fork]
        index -= 1 if index - 1 >= 0 else 0
        fork_map = del_fork_map(fork_map, fork)
        try :
            fork = fork_map['index-fork'][index]
            fork_map['fork'][fork] += 1    
        except KeyError : break
    return fork_map
    
# game reading 

def scatter(possible_path, length) : # nouveau
    next_tiles = [(x,y) for x in range(-1,2) for y in range(-1,2) if (x,y) != (0,0)]
    spread_list = []
    sector_list = []
    for key in possible_path.keys() :
        sector_list.append(sector(key))
        if possible_path[key] == 1 :
            cursor_list = [add_tuple(key, tiles) for tiles in next_tiles]
            count = 0
            for cursor in cursor_list :
                try : possible_path[cursor]
                except KeyError : continue
                if possible_path[cursor] == 1 : count += 1
                spread_list.append(1 - (0.1 * count) if count >= 2 else 1)
    sector_value = math.log(len(set(sector_list)) + 1, 10)
    length_value = math.sin(length * (math.pi / 2) / constant['max_length'])
    spread_value = stat.mean(spread_list)
    scatter_value = stat.mean(list(possible_path.values()))
    return 0.30*spread_value + 0.30*sector_value + 0.15*length_value + 0.25*scatter_value

def hunting() :
    return 0

# possible_path

def run_map(play_map, init_fork_map ={'fork':{}}, command ='gameloop') :
    possible_path = {}
    
    for tile in game_map['brows'] :
        #if off_side_max( add_tuple(tile, play_map['max'])) : continue
        fork_map = copy.deepcopy(init_fork_map)
        possible_path[tile] = run_path(tile, play_map, fork_map)     
    # if command == 'gameloop' : show_map(possible_path)
    return possible_path

def run_path(tile, play_map, fork_map, start=True) :
    cursor = initial_cursor(play_map, fork_map, tile)
    controller = {'blocking' : False,  'end_path' : False, 'stop' : True}
    possible_path = 0 # possible path for this tile
    
    while True :
        
        "A : embranchement : "
        if fork_map['fork'].get(cursor['idx']) != None :
            fork_map = update_fork_map(cursor['idx'], fork_map)
            controller['stop'] = stop(fork_map)
        "B : obstacle : " 
        controller['blocking'] = blocking(cursor['tile'], play_map['sector'], cursor['idx'])
        "C : bout de path : " 
        controller['end_path'] = True if cursor['idx'] == play_map['length'] - 1 else False

        # debug_run_path(controller, cursor, fork_map, tile) # DEBUG MOD
            
        if controller['end_path'] == True and controller['blocking'] == False : possible_path += 1
        
        if controller['stop'] == False :
            if controller['blocking'] == True or controller['end_path'] == True :
                cursor = initial_cursor(play_map, fork_map, tile)
                continue
        else :
            if controller['blocking'] == True or controller['end_path'] == True :
                return possible_path
        
        cursor = update_cursor(cursor, play_map, fork_map)

# game

def game_entry(his_play_map, my_play_map, target) :
    game_keys = [
                 'x','y',              'my_life',
                 'his_life',           'torpedo_cooldown',
                 'sonar_cooldown',     'silence_cooldown',
                 'mine_cooldown'
                                                         ]
    if test_mod == False :
        input_ = [int(i) for i in input().split()]
        game = dict(zip(game_keys, input_))
        game['my_position'] = game['x'],game['y']
        del game['x'],game['y']
        sonar_result = input()
        his_order = input()
    else :
        input_ = [0 for i in range(4)]
        game = dict(zip(game_keys[4:8], input_))
        game.update({
                     'my_position' : my_play_map['position'],
                     'my_life'     : 6,
                     'his_life'    : 6,
                    })
        sonar_result = 'NA'
        his_play_map = next_tile(his_play_map, target, 'he')
    return

def manage_order(order, play_map, sonar_result) :
    message_order = [cursor.split() for cursor in order.split('|')]
    for order_cursor in message_order :
        if order_cursor[0] == 'MOVE' : play_map['dir'].append( dir_converter(order_cursor[1]) )
        elif order_cursor[0] == 'SILENCE' : play_map['dir'].append(dir_converter('silence'))
        elif (order_cursor[0] == 'SURFACE' or order_cursor[0] == 'SONAR'
             ) : play_map['sector']['in'][lap] = order_cursor[1]
        elif order_cursor[0] == 'TORPEDO' :
            shoot_tile = order_cursor[1], order_cursor[2]
            play_map['sector']['tiles'][lap] = torpedo_area(shoot_tile)
        if 'NA' not in sonar_result : 
            if   sonar_result[1] == 'Y' : play_map['sector']['in'][lap - 1] = sonar_result[0]
            elif sonar_result[1] == 'N' : play_map['sector']['out'][lap - 1] = sonar_result[0]
        # problÃ¨me synchronisation : vÃ©rifier
        # play_map['position'] = [ list(filter(lambda key : possible_path[key] == 1, possible_path))] 
    return config_play_map(play_map, 
                           dir_path = play_map['dir'], 
                           position = play_map['position'],
                           sector = play_map['sector']) ### A REVOIR

def play() :
    return

def game_loop(my_play_map, his_play_map, target) : # nouveau
    global lap
    lap = 0
    while True :
        print(lap)
        
        sonar_result, his_order, my_submarine = game_entry(his_play_map, my_play_map, target)
        
        his_play_map = manage_order(his_order, his_play_map, sonar_result, 'he')
        
        target = config_target(my_play_map, his_play_map)
        
        play(my_play_map, target) 
        """
        ma fonction qui sert Ã  prendre des dÃ©cisions, Ã  Ã©diter la sortie et Ã  mettre Ã  jour play_map
        """          
        lap += 1
        
        # my_play_map = update_play_map(my_play_map, game)
        return 

def start() : # nouveau
    my_play_map = config_play_map()
    his_play_map = config_play_map()
    target = config_target(my_play_map, his_play_map, 'start')
    
    my_play_map = next_tile(my_play_map, target, 'start')
    print(my_play_map['position'])
    start_tile = my_play_map['position']
    
    if test_mod == False : 
        print(*start_tile, sep = ' ')  
    else : 
        print(f'my_start tile : {start_tile}')
        his_play_map = next_tile(my_play_map, target, 'start')
        print(f"his_start tile : {his_play_map['position']}")
    return my_play_map, his_play_map, target

def main(): ### nouveau
    config_constant()
    config_game_map()
    # debug_built_path_process(30)
    start_time = perf_counter()
    my_play_map, his_play_map, target = start()
    game_loop(my_play_map, his_play_map, target)
    print(f'time : {round(perf_counter() - start_time,2)}')

if __name__ == '__main__' : main()
