# Library

from random import choice
from random import choices
from random import randrange # nouveau ?
from random import sample
from time import perf_counter
import statistics as stat
import math
import copy

# debug

def debug_map(content, game_map) :
    # give graphics overview of the value of each tiles, content is a dic with tuple (x,y) as key
    for y in range(game_map['size']):
        line = []
        for x in range(game_map['size']):
            try : line.append(f'{content[x,y]:02}')
            except KeyError : line.append('XX')
        print(*line, sep=' ')   

def debug_path(path, show_path = False):
    tile_cursor = (0,0)
    path_cursor = [tile_cursor]
    for direction in path :
        tile_cursor = add_tuple(tile_cursor, direction[0])
        path_cursor.append( tile_cursor)
    
    min_x = min([xy[0] for xy in path_cursor])
    min_y = min([xy[1] for xy in path_cursor])
    correction = -min_x, -min_y
    path_cursor = list(map(lambda xy : add_tuple(xy, correction),path_cursor))
    path_cursor = { key : value for value,key in enumerate(path_cursor) }
    max_x = max([xy[0] for xy in path_cursor])
    max_y = max([xy[1] for xy in path_cursor])
    spread = abs(max_x - min_x) * abs(max_y - min_y)
    
    if show_path == True :
        for y in range(max_y + 1) :
            line = []
            for x in range(max_x + 1) :
                if (x,y) in path_cursor :
                    line.append(f'{path_cursor[(x,y)]:02}')
                else : line.append('__')
            print(*line, sep=' ')
    else : return spread

def debug_run_path(controller, cursor, fork_map, tile, cmd = '', r = '') :
        """ position in debug line:
        1           tile                      -> tile from which dir_ starts to browse 
        2           cursor['idx']             -> index in dir_
        3           block/end_path            -> when blocking or end_path is true
        4 fork_map['fork']/fork_map['max']    -> main information on the situation in fork_map
        '_' if nothing
        OPTION : if cmd = 'cursor','fork_map', 'controller' print one or several contain
        """
        show = (max([controller['blocking'], controller['end_path']]),
                controller['blocking'],
                controller['end_path']) 
        fork_map_situation = [str(fork) + '/' + str(max_)
                              for fork in list(fork_map['fork'].values())
                              for max_ in list(fork_map['max'].values()) ]
        space = ' ' * 25 if tile[1] % 2 != 0 else '' # just to see more tile changing
        r += (space + str(tile)) * show[0]
        r += (' ' + str(cursor['idx'])) * show[0]
        r += (' ' + ('block')) * show[1]
        r += (' ' + ('end_path')) * show[2]
        r += (' ' + str(*fork_map_situation if fork_map_situation else '_'))* show[0]
        r += (' ' + str(controller['stop'])) * show[0]
        if  'fork_map' in cmd : r += (' ' + str(fork_map)) * show[0]
        if 'cursor' in cmd : r += (' ' + str(cursor)) * show[0]
        if 'controller' in cmd : r += (' ' + str(controller))* show[0]
        if r : print(r)
        else : pass

def debug_built_path_process(game_map, parameters, num_test) : # nouveau
    import matplotlib.pyplot as plt
    current_path = config_play_map(position = game_map['brows'])
    count = 0
    path_length, path_value, process_time, swing_turn, path_spread = [], [], [], [], []
    while count != num_test :
        rand_path, value, turn, time = next_tile(current_path, game_map, parameters)
        length = len(rand_path)
        spread = debug_path(rand_path)
        path_length.append(length)
        path_value.append(value)
        process_time.append(time)
        swing_turn.append(turn)
        path_spread.append(spread)
        count += 1

    print(*[(f' length : {round(stat.mean(path_length),2) , round(stat.pstdev(path_length),2)}' ),
            (f' value  : {round(stat.mean(path_value),2)  , round(stat.pstdev(path_value),2)}'  ),
            (f' time   : {round(stat.mean(process_time),2), round(stat.pstdev(process_time),2)}'),
            (f' turn   : {round(stat.mean(swing_turn),2)  , round(stat.pstdev(swing_turn),2)}'  ),
            (f' spread : {round(stat.mean(path_spread),2) , round(stat.pstdev(path_spread),2)}' ),
           ], sep = '\n'
         )
    plt.plot(path_length)
    plt.plot(path_value)
    plt.plot(process_time)
    plt.plot(swing_turn)
    plt.plot(path_spread)

# tools

def add_tuple (tuple_1, tuple_2) :
    return tuple_1[0] + tuple_2[0], tuple_1[1] + tuple_2[1]

def normal_law(x,s2,mu): # nouveau
    sigma = math.sqrt(s2)     
    return (1 / (sigma * math.sqrt(2 * math.pi))) * math.exp((-1 / 2) * (((x - mu)/sigma) ** 2))

def dir_tile_converter(direction_path, start_tile=(0,0)) :
    tile_path = [start_tile]
    current_tile = start_tile
    for current_direction in direction_path :
        current_tile = add_tuple(current_tile, current_direction[0])
        tile_path.append(current_tile)
    return tile_path

# game_map

def config_game_map(parameters) : # nouveau
    if parameters['test_mod'] == False :
        width, height, my_id = [int(i) for i in input().split()]
        size = width if width == height else 'problem'
    else : 
        size = parameters['size_map']
        weights = [normal_law(i,s2=2,mu=4) for i in range(11)] 
        num_island = choices([i for i in range(11)], weights)
        tiles = [(x,y) for x in range(size) for y in range(size)]
        print(num_island)
        island = sample(tiles, *num_island)
        brows = [xy for xy in tiles if xy not in island]
        print(island)
    return {'island' : island, 'size' : size, 'brows' : brows}

def config_play_map(play_map  = None,
                    dir_path  = [], 
                    tile_path = [], 
                    position  = [],
                    sector    = {'in' : {}, 'out' : {}, 'tiles' : {}} ### nouveau : avant : config_dir_map
                   ) :
    """
    Configure play_map wich is the most important (and almost unique) place where are compute player information.
    Both players have their own play_map which contains all the information about the player's game. 
    It is dictionnary containing several types of variable and sequences. 
    
    All lists are ordered. Which means that all the information appeared at the same index on each 
    list corresponds to the same lap. 
    
    'dir' :       list of list of tuples representing directions previously followed by the submarine.
                  [[(0,-1)],[(0,-1)],[(1,0)]] is North, North, West. Sometimes, when the opposit players play 
                  'Silence' there is several tuples the list of list : [[(0,1)],[(0,1),(0,-1)]]
                  See dir_converter for all details.
                  
    'max' :       tuple representing respectively beetween max West and max East and the max North and 
                  the max South followed by 'dir'. [(0,-1),(0,-1),(1,0)] -> play_map['max'] = (1,2) 
                  because there two movement in est-west and one in north-south.
                  
    'length' :    length of 'dir'. avoid two employ len(play_map['dir']) several times in the game.
    
    'fork'   :    the list of index of the list of list of 'dir' where there is more than one tuples :
                  [[(0,1)],[(0,1),(0,-1)],[(0,1)],[(0,1),(0,-1)]] give play_map['fork'] = [1,3].
                  
    'sector' :    dictionnary of three dictionnaries built in the same way. 'In' contains sector where 
                  submarine must be at a given lap. 'in' : { 0 : 1} mean 'the submarine must be in sector 
                  1 at lap 0' wich correspond also to play_map['dir'][0] and play_map['last_tiles'][0] 
                  wich are the index 0 of 'dir' list and 'last_tiles' list.
                  
    'position' :  tuple (x,y) representing the current position of (x,y).
    
    'last_tiles : list of tuples representing tiles previously traveled by the submarine'.
                  [(1,2),(1,1),(1,1),(0,0)] when following the 'dir' exemple above.
    """
    if play_map :
        if not dir_path  : dir_path  = play_map['dir']
        if not tile_path : tile_path = play_map['last_tiles'] 
        if not position  : position  = play_map['position']
        if not sector    : sector    = play_map['sector'] ### sector est bien maj en bloc ???

    play_map = {
                'dir'          : dir_path , 
                'max'          : (
                                  sum([xy[0][0] for xy in dir_path if len(xy) == 1]) ,
                                  sum([xy[0][1] for xy in dir_path if len(xy) == 1]) 
                                 ), 
                'length'       : len(dir_path),
                'fork'         : [idx for idx in range(len(dir_path)) if len(dir_path[idx]) != 1],
                'sector'       : sector,
                'position'     : position,
                'last_tiles'   : tile_path
               }
    if play_map['position'] not in play_map['last_tiles'] : play_map['last_tiles'].append(play_map['position'])
    return play_map

# run path : map

def off_side_max(max_, size) :
    e_w, n_s = max_
    return (e_w not in range(0,size) or n_s not in range(0,size))

def off_side_tile (tile, size) :
    x,y = tile
    return (x not in range(0,size) or y not in range(0,size)) # 1 c'est pas logique

def sector (xy) :
    sector = {'1': [ 0, 5, 0, 5], '2' : [ 0, 5, 5,10], '3' : [ 0, 5,10,15],
              '4': [ 5,10, 0, 5], '5' : [ 5,10, 5,10], '6' : [ 5,10,10,15],
              '7': [10,15, 0, 5], '8' : [10,15, 5,10], '9' : [10,15,10,15]}
    for i in '123456789' :
        if sector[i][0] <= xy[0] < sector[i][1] and sector[i][2] <= xy[1] < sector[i][3] : 
            return int(i)

def dir_converter(key) :
    # NB : can't put list of tuple as key
    dir_dic = { (-1, 0) : 'W', 'W' : [(-1, 0)],
                ( 1, 0) : 'E', 'E' : [( 1, 0)],
                ( 0,-1) : 'N', 'N' : [( 0,-1)],
                ( 0, 1) : 'S', 'S' : [( 0, 1)],
                'silence' : list(set([(x,0) for x in range(-4,5)] + [(0,y) for y in range(-4,5)])) }
    return dir_dic[key]

# start_tile

def random_path(initial_play_map, game_map, parameters) : # nouveau
    direction = [ [(1,0)], [(-1,0)], [(0,1)], [(0,-1)] ]
    while True :
        temp_direction = [(0,0)]
        first_direction = None
        counter = 0
        current_direction_path = copy.deepcopy(initial_play_map['dir'])
        current_tile = choice(initial_play_map['position'])
        current_tile_path = (
                              copy.deepcopy(initial_play_map['last_tiles']) 
                              if parameters['status'] != 'me'
                              else dir_tile_converter(initial_play_map['dir'], current_tile)
                            )
        while True :
            temp_direction = choice(direction)
            temp_tile = add_tuple(current_tile,temp_direction[0])
            if temp_tile not in current_tile_path and blocking(temp_tile, game_map) == False :
                if first_direction == None : first_direction = temp_direction
                current_direction_path.append(temp_direction)
                current_tile = temp_tile
                current_tile_path.append(current_tile)
                counter = 0
                if len(current_direction_path) == parameters['max_length'] : 
                    return current_direction_path, first_direction
            else :
                counter += 1
                if counter > 6 and first_direction != None : 
                    return current_direction_path, first_direction
                elif counter > 6 : break
        

# game_loop : orders

def torpedo_area(center, game_map) :
    ref_position = center
    current_position = ref_position
    direction = [ [(1,0)], [(-1,0)], [(0,1)], [(0,-1)] ]
    torpedo_area = []
    torpedo_range = 4
    range_, try_, max_try = 0, 0, torpedo_range**6
    while True :
        try_ += 1
        range_ += 1
        current_direction = choice(direction)
        current_position = add_tuple(current_position,current_direction[0])
        if blocking(current_position, game_map) :
            current_position = ref_position
            range_ = 0
            continue
        if current_position not in torpedo_area and current_position != ref_position :
            torpedo_area.append(current_position)
            current_position = ref_position
            try_ = 0
            range_ = 0
        if range_ == torpedo_range : 
            current_position = ref_position
            range_ = 0
        if try_ == max_try or len(torpedo_area) == 40 : return torpedo_area

def manage_order(index, order, play_map, game_map, sonar_result) :
    message_order = [cursor.split() for cursor in order.split('|')]
    for order_cursor in message_order :
        if order_cursor[0] == 'MOVE' : play_map['dir'].append( dir_converter(order_cursor[1]) )
        elif order_cursor[0] == 'SILENCE' : play_map['dir'].append(dir_converter('silence'))
        elif (order_cursor[0] == 'SURFACE' or order_cursor[0] == 'SONAR'
             ) : play_map['sector']['in'][index] = order_cursor[1]
        elif order_cursor[0] == 'TORPEDO' :
            shoot_tile = order_cursor[1], order_cursor[2]
            play_map['sector']['tiles'][index] = torpedo_area(shoot_tile, game_map)
        if 'NA' not in sonar_result : 
            if   sonar_result[1] == 'Y' : play_map['sector']['in'][index - 1] = sonar_result[0]
            elif sonar_result[1] == 'N' : play_map['sector']['out'][index - 1] = sonar_result[0]
    return config_play_map(play_map, dir_path = play_map['dir'], sector = play_map['sector']) ### A REVOIR

# run path : cursor

def initial_cursor(play_map, fork_map, tile) :
    # 'dir' : current position in play_map
    # 'idx' : current index in play_map
    # 'fork' : least embranchement '' if no fork
    # 'tile' : current tile on map
    init_cursor = {'dir' : (), 'idx' : 0, 'tile' : () }
    init_cursor['dir'] = ( 
                          play_map['dir'][0][fork_map['fork'][0]-1] 
                          if fork_map['fork'].get(0) != None
                          else play_map['dir'][0][0]
                         )
    init_cursor['tile'] = add_tuple(tile, init_cursor['dir'])
    return init_cursor

def update_cursor (cursor, play_map, fork_map) :
    cursor['idx'] += 1
    branch_index = ( 
                    fork_map['fork'][cursor['idx']] 
                    if fork_map['fork'].get(cursor['idx']) != None
                    else 0 
                   )
    cursor['dir'] = play_map['dir'][ cursor['idx'] ] [branch_index]
    cursor['tile'] = add_tuple(cursor['tile'], cursor['dir'])
    return cursor

# run_path : fork_map
            
def config_fork_map (play_map) :
    # how fork_map is built :
    fork_map = {'fork' : {}, 'max' : {}, 'fork-index': {}, 'index-fork' : {}}
    index = 0
    for fork in play_map['fork'] :
        fork_map['fork'][fork] = 0
        fork_map['max'][fork] = len(play_map['dir'][fork])
        fork_map['fork-index'][fork] = index
        fork_map['index-fork'][index] = fork
        index += 1
    return fork_map

def del_fork_map (fork_map, fork) :
    index = fork_map['fork-index'][fork] 
    for cursor in ['fork', 'max', 'fork-index'] : del fork_map[cursor][fork]
    del fork_map['index-fork'][index]
    return fork_map

def update_fork_map(fork, fork_map): 
    fork_map['fork'][fork] += 1
    while fork_map['fork'][fork] > fork_map['max'][fork] :
        index = fork_map['fork-index'][fork]
        index -= 1 if index - 1 >= 0 else 0
        fork_map = del_fork_map(fork_map, fork)
        try :
            fork = fork_map['index-fork'][index]
            fork_map['fork'][fork] += 1    
        except KeyError : break
    return fork_map

# run_path : controller

def blocking(tile, game_map, sector = {'in' : {}, 'out' : {}, 'tiles' : {}}, index = None) : # revoir : sector_map
    blocking = (    True 
                    if tile in game_map['island'] 
                    or off_side_tile(tile, game_map['size']) 
                    or ( sector['in'].get(index) != None 
                            and sector['in'].get(index) != sector(tile) )
                    or ( sector['out'].get(index) != None
                         and tile not in sector['out'].get(index) )
                    else False
                )
    return blocking

def stop(fork_map) :
    if len(fork_map['fork'].keys()) != len(fork_map['max'].keys()) : 
        raise ValueError('fork_map')
    if (len(fork_map['fork'].keys()) == 1 and 
        list(fork_map['fork'].values()) == list(fork_map['max'].values())) :
        return True
    else : return False
    
# game reading 

def scatter(possible_path, length, max_length) : # nouveau
    next_tiles = [(x,y) for x in range(-1,2) for y in range(-1,2) if (x,y) != (0,0)]
    spread_list = []
    sector_list = []
    for key in possible_path.keys() :
        sector_list.append(sector(key))
        if possible_path[key] == 1 :
            cursor_list = [add_tuple(key, tiles) for tiles in next_tiles]
            count = 0
            for cursor in cursor_list :
                try : possible_path[cursor]
                except KeyError : continue
                if possible_path[cursor] == 1 : count += 1
            spread_list.append(1 - (0.1 * count)) if count >= 2 else 1
    sector_value = math.log(len(set(sector_list)) + 1, 10)
    length_value = math.sin(length * (math.pi / 2) / max_length)
    spread_value = stat.mean(spread_list)
    return spread_value * sector_value * length_value

def hunting() :
    return 0

# main engine

def next_tile(play_map, game_map, parameters) : # nouveau
    "debut de fonction (app)"
    best_value, value, try_, swing_turn, swing_time = 0, 0, 0, 0, 0
    possible_path = []
    start_time, time = perf_counter(), 0
    max_time = parameters['start_time'] if parameters['status'] == 'start' else parameters['turn_time']
    while time < max_time :
        ratio = False
        while ratio == False :
            current_random_dir_map, current_next_direction = random_path(play_map, game_map, parameters) ###
            length_ratio = len(current_random_dir_map) / parameters['max_length']
            time = perf_counter() - start_time
            time_ratio = time / max_time
            ratio = length_ratio > time_ratio  
            if time >= max_time : break
        
        current_random_play_map = config_play_map(play_map, dir_path = current_random_dir_map)
        current_possible_path   = run_map( game_map, current_random_play_map)
        hiding_value = scatter(current_possible_path,current_random_play_map['length'],parameters['max_length'])
        hunting_value = hunting()
        target = parameters['target']
        
        value = round( (1-target) * hiding_value + target * hunting_value, 2)
        
        if value > best_value :
            swing_turn = try_
            swing_time = perf_counter() - start_time
            best_value = value
            possible_path  = [current_possible_path]
            random_play_map = [current_random_play_map]
            next_direction = [current_next_direction]
        elif value == best_value :
            possible_path.append(current_possible_path)
            random_play_map.append(current_random_play_map)
            next_direction.append(current_next_direction)
        time = perf_counter() - start_time
        try_ += 1
    
    idx = randrange(len(possible_path))
    possible_path = possible_path[idx]
    random_play_map = random_play_map[idx]
    next_direction = next_direction[idx]
    # debug_map(possible_path, game_map)
    # debug_path(random_play_map['dir'],show_path=True)
    if parameters['test_mod'] == False :
        if parameters['status'] == 'start' : 
            return choice( [key for key in possible_path if possible_path[key] > 0] )
        else : return next_direction
    else : return random_play_map['dir'], best_value, swing_turn, swing_time

def run_map(game_map, play_map, init_fork_map ={'fork':{}}, command ='gameloop') :
    # integrer dans un run map un filtre ('max_NS','max_EW')
    possible_path = {}
    for tile in game_map['brows'] :
        #if off_side_max( add_tuple(tile, play_map['max']), game_map['size']) : continue
        fork_map = copy.deepcopy(init_fork_map)
        possible_path[tile] = run_path(tile, game_map, play_map, fork_map)     
    # if command == 'gameloop' : show_map(possible_path, game_map)
    return possible_path

def run_path(tile, game_map, play_map, fork_map, start=True) :
    cursor = initial_cursor(play_map, fork_map, tile)
    controller = {'blocking' : False,  'end_path' : False, 'stop' : True}
    possible_path = 0 # possible path for this tile
    
    while True :
        
        "A : embranchement : "
        if fork_map['fork'].get(cursor['idx']) != None :
            fork_map = update_fork_map(cursor['idx'], fork_map)
            controller['stop'] = stop(fork_map)
        "B : obstacle : " 
        controller['blocking'] = blocking(cursor['tile'], game_map, play_map['sector'], cursor['idx'])
        "C : bout de path : " 
        controller['end_path'] = True if cursor['idx'] == play_map['length'] - 1 else False

        # debug_run_path(controller, cursor, fork_map, tile) # DEBUG MOD
            
        if controller['end_path'] == True and controller['blocking'] == False : possible_path += 1
        
        if controller['stop'] == False :
            if controller['blocking'] == True or controller['end_path'] == True :
                cursor = initial_cursor(play_map, fork_map, tile)
                continue
        else :
            if controller['blocking'] == True or controller['end_path'] == True :
                return possible_path
        
        cursor = update_cursor(cursor, play_map, fork_map)

# game

def start(game_map, parameters) : # nouveau
    start_play_map = config_play_map(position = game_map['brows'])
    start_tile = next_tile(start_play_map,game_map, parameters)
    return start_tile

def game_loop(game_map, parameters) : # nouveau
    lap = 0
    sonar_result = 'NA'
    his_play_map = config_play_map()
    my_play_map  = config_play_map()
    
    while True :
        """
        x, y, my_life, opp_life, torpedo_cooldown, sonar_cooldown, silence_cooldown, mine_cooldown = [int(i) for i in input().split()]
        my_position = (x,y)
        sonar_result = sonar_result, input()
        """
        
        # random_path _> play_map['current_tile] continuer
        
        #his_play_map = manage_order(lap, input(), his_play_map, game_map, sonar_result)

        #direction = dir_converter( my_play_map['dir'][lap][0] )

        lap += 1
        return 
        
def main(): ### nouveau
    parameters = {
                    'test_mod'   : True,      # to run the program on a console
                    'size_map'   : 15,        # default size of when we are in test mod
                    'status'     : 'start',   # 'start' at start and 'me' or 'he'in game loop
                    'start_time' : 0.8,       # how much time we can run next_tiles() at start
                    'turn_time'  : 0.4,       # how much time we can run next_tiles() in game_loop
                    'ref_length' : 16,        # best length of play_map['dir'] in next_tiles()
                    'max_length' : 22,        # max length of play_map['dir'] in next_tiles()
                    'target'     : 0          # float beetween 0 and 1 describing the behavior of the submarine. Very defensive in 0, very offensive in 1
                 }
    game_map = config_game_map(parameters)
    debug_built_path_process(game_map, parameters, 30)
    start_time = perf_counter()
    start_tile = start(game_map, parameters) 
    # print(*start_tile, sep = ' ')
    game_loop(game_map, parameters)  

if __name__ == '__main__' : main()
