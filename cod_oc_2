global map_, possible_path

# parameters

max_path = 5 # ??
side = 15
his_path = []
his_silence_count, his_laps = 0,0
# main variables 
"""
my_command : list with all(?) my previous command
my_order : list of list of tuples with all my move as perceived by my enemy
already  : all the tiles where i have allready been
his_order : list of list of tuples with all his possible move : 
                can suppot only one silence without beeing deleted
***
"""
# usual function

def add (tuple_1, tuple_2) :
    return tuple_1[0] + tuple_2[0], tuple_1[1] + tuple_2[1]

def middle(x,y) :
    return 7-abs(7-x)+7-abs(7-y)

def in_island(x,y,island) :
    return (not (x,y) in island)

def sector (x,y) :
    sector = {'1': [0,5,0,5],  '2' : [0,5,5,10],  '3' : [0,5,10,15],
              '4': [5,10,0,5],  '5' : [5,10,5,10],  '6' : [5,10,10,15],
              '7': [10,15,0,5],'8' : [10,15,5,10],'9' : [10,15,10,15]}
    for i in '123456789' :
        if sector[i][0] <= x <= sector[i][1] and sector[i][2] <= y < sector[i][3] : return i
    return 'x'

def direction(order) :
    r = ''
    if 'MOVE' in order :
        if 'N' in order : r = 'N'
        if 'S' in order : r = 'S'
        if 'E' in order : r = 'E'
        if 'O' in order : r = 'O'
        if 'SILENCE' in order : r = 'Silence'
    return r

def move (direction,laps) :
    l_ = laps + 1
    step = { 'N' : [(0,-1,l_)], 
             'S' : [(0,1,l_)], 
             'E' : [(1,-1,l_)], 
             'O' : [(-1,0,l_)], 
            'Silence' : [(-3,0,l_),(-2,0,l_),(-1,0,l_),(0,-3,l_),(0,-2,l_),(0,-1,l_),
                         (3,0,l_),(2,0,l_),(1,0,l_),(0,3,l_),(0,2,l_),(0,1,l_)]}
    return step[direction]


# Function to brows paths, endures one silence

def run_map(brows_map,path,island) : # brows_map designe une list de tuple sans les tuples des islands
    map_ = {}
    for xy in brows_map :
        map_[xy] = run_path(possible_path(xy,path),island)
    return map_   

def possible_path(position, path): # le path par rapport à une position de référence
    possible_path = []
    for i in range(len(path)) :
        possible_path.append([])
        for j in range(len(path[i])) :
            possible_path[i] += (path[i][j][0] + position[0], path[i][j][1] + position[1], path[i][j][2]), # pas juste : les valeurs se cumulent !!!
    return possible_path

# pour l'heure my_position n'a qu'une position. Il faut que la fonction possiblepath teste toute les positions de la map

def run_path(path,island): # nb : un seul 'sielence' possible
# list of list of tuples : [(x,y,laps)],[()],[(),(),()],[()]
    possible_path = 0
    i,j = 0,0
    loop = 'x'
    while True :
        if i == len(path) : # 3 en bout de path
            possible_path += 1
            if loop == 'o':
                i = 0
            else : 
                return possible_path
        if len(path[i]) == 1 :
            if path[i][0][0:2] in island or not 0 <= path[i][0][0] < side or not 0 <= path[i][0][1] < side : # sur un island sans embranchement ou hors-jeu
                return possible_path
        if len(path[i]) != 1 : # 2 a un enbranchement
            if j == len(path[i]) - 1 : 
                loop = 'x'
                if path[i][j][0:2] in island :
                    return possible_path 
            else :
                j += 1
                loop = 'o'
                if path[i][j][0:2] in island :
                    i = 0
        i = path[i][0][2]     

# map 

width, height, my_id = [int(i) for i in input().split()] # we use 'side' witch is 15

brows_map, island, already = [],[],[]
for y in range(side):
    line = input()
    for x in range(side) :
        if line[x] == 'x' : island.append((x,y)) # x -> island else .
        else : brows_map.append((x,y))

# Firt lap
# 7-abs(7-x)+7-abs(7-y) ==> pour valoriser le milieu
r = (0,0)
if (7,7) not in island : r = (7,7)
elif (4,5) not in island : r = (4,5)
elif (9,5) not in island : r = (9,5)
elif (9,9) not in island : r = (9,9)
elif (5,9) not in island : r = (5,9)
else : r = (2,7)
print(*r) 

# game loop
while True:
    x, y, my_life, his_life, torpedo, sonar, silence, mc = [int(i) for i in input().split()]  ####
    sonar_result = input() ####

    # his path 
    his_order = input().replace('|', ' ').split() # his_order = ['move','N','Torpedo] ####
    
    if 'MOVE' in his_order :
        his_path.append(move(direction(his_order),his_laps))
        his_laps += 1 # laps start from 0

    else : 
        if 'SILENCE' in his_order :
            his_silence_count += 1
            if his_silence_count > 1 : # if there is two silence we restat from 0, no path for this turn
                his_path = []
                his_laps = 0
                his_silence_count = 0            

    if his_path :
        map_ = run_map(brows_map,his_path,island)
        print(f'MOVE N SILENCE | MSG {map_}')
    else : print('MOVE N SILENCE')

"""
    already.append((x,y))
    decision, max_, isit = d_isit(his_order, max_, island)
    if decision != 'wait' : z, result = hunt(x, y, isit, already, torpedo)
    else : z, result = wait(x, y, silence, island, already)
    if z == 'x' : already = []
    print(result)
        # f'| MSG {isit}'

"""
