import statistics as stat
import random
import math
import copy

from sklearn.model_selection import train_test_split
from time import perf_counter

"MENU"

DEBUG = True
MESSAGE = True

# instruction
MSG = {'his_search_map' : True}
OPT = {'sampling' : True, 'start' : True, 'game_loop' : True, 'one_path' : True}
SHOW = {'island' : False, 'path' : False}
TEST = {'heat_map' : False, 'next_tile' : False, 'random_path' : False}
DSPL = {'check_search_map' : False, 'run_path' : False, 'path' : False , 'search_map' : False}
DFLT = {'next_tile_security' : False, 'check_search_map' : False} # do not touch

# constant
MAP = {'torpedo' : 5, 'size' : 15}
COOLDOWN = {'torpedo' : 3, 'sonar' : 4, 'silence' : 6, 'mine' : int(),}
TIME = { 'start' : 0.65, 'start_limit' : 0.999, 'turn' : 0.025, 'turn_limit' : 0.049, 'heat_map' : 0.0055}
FLOOR = {'sampling' : 56, 'sonar' : 75, 'torpedo' : 12, 'torpedo_pwr' : 36, 'silence_pwr' : 36}
NUM = {'length' : 10, 'test' : 60, 'laps' : 20, 'sampling' : 0.1, 'heat_map' : 14}  

def main():
    g_timer()
    config_global_var()
    check_search_map()
    config_map()
    if TEST['random_path'] : return test_random_path()
    if TEST['next_tile'] : return test_next_tile()
    if TEST['heat_map'] : return test_heat_map() 
    if OPT['start'] : my_play_map, his_play_map = start()
    if OPT['game_loop'] and not DSPL['search_map'] and not DSPL['path'] :
        game_loop(my_play_map, his_play_map)
    g_timer('print')

" STEP OF THE GAME "

def start() :
    i_timer()
    my_play_map = init_play_map(me = True, start = True)
    his_play_map = init_play_map(me = False, start = True)
    my_play_map = next_tile(my_play_map)
    start_tile = my_play_map['position']
    if not DEBUG : print(*start_tile, sep = ' ')  
    elif DSPL['path'] or DSPL['search_map'] : print(f'my_start_tile : {start_tile}')
    else : 
        i_timer()
        print(f'my_start_tile : {start_tile}')
        his_play_map = next_tile(his_play_map)
        print(f"his_start tile : {his_play_map['position']}")
    return my_play_map, his_play_map

def game_loop(my_play_map, his_play_map) :
    global lap
    lap = 0
    if DEBUG : print(f"lap : {lap}")
    my_play_map['start'] = False
    his_play_map['start'] = False
    while True :
        my_play_map, his_play_map = game_input(my_play_map, his_play_map)
        his_play_map = he_play(my_play_map, his_play_map)
        my_play_map = i_play(my_play_map, his_play_map)
        test_time(my_play_map)
        lap += 1
        if DEBUG : print(f"lap : {lap}")
        if loop(my_play_map, his_play_map) : break

" GAME LOOP MANAGER "

def game_input(my_play_map, his_play_map) :
    i_timer()
    if not DEBUG :
        keys   = ['x', 'y', 'my_life', 'opp_life', 'torpedo_cooldown', 'sonar_cooldown', 'silence_cooldown', 'mine_cooldown']
        values = [int(i) for i in input().split()]
        input_ = dict(zip(keys, values))
        input_['position'] = input_['x'],input_['y']
        input_.pop('x')
        input_.pop('y')
        input_['sonar_result'] = input()
        input_['his_order'] = input()
    else : input_ = create_input(my_play_map, his_play_map)
    his_play_map['life'] = input_['opp_life']
    his_play_map['order'] = input_['his_order']
    my_play_map.update({'position'         : input_['position'],
                        'life'             : input_['my_life'],
                        'torpedo_cooldown' : input_['torpedo_cooldown'],
                        'sonar_cooldown'   : input_['sonar_cooldown'],
                        'silence_cooldown' : input_['silence_cooldown'],
                        'mine_cooldown'    : input_['mine_cooldown'],
                        'sonar_result'     : input_['sonar_result']
                        })
    return my_play_map, his_play_map

def he_play(my_play_map, his_play_map) :
    i_timer()
    if his_play_map['order'] == 'NA' : return his_play_map
    message_order = [cursor.split() for cursor in his_play_map['order'].split('|')]
    for order_cursor in message_order :
        if order_cursor[0] == 'SURFACE' :
            sector = int(order_cursor[1])
            his_play_map = surface_play_map(his_play_map, sector)
        else :
            if order_cursor[0] == 'MOVE' : 
                his_play_map['next_direction'] = dir_converter(order_cursor[1])
            if order_cursor[0] == 'SILENCE' : 
                his_play_map['silence'] = True
            if order_cursor[0] == 'SONAR' : 
                sector = int(order_cursor[1])
                his_play_map['sector_in'].update({lap : sector})
            if order_cursor[0] == 'TORPEDO' :
                shoot_tile = int(order_cursor[1]), int(order_cursor[2])
                his_play_map['sector_tiles'].update({lap : shoot_tile}) 
            # if Mine in order_cursor : ....
            if    my_play_map['sonar_result'] == 'Y' : his_play_map['sector_in'].update({lap - 1 : my_play_map['sonar']})
            elif  my_play_map['sonar_result'] == 'N' : his_play_map['sector_out'].update({lap - 1 : my_play_map['sonar']})
            
    his_play_map = update_play_map(his_play_map, my_play_map)
    if DEBUG : print(f"his order : '{his_play_map['order']}' ({round(perf_counter()-i_time,3)})")
    return his_play_map

def i_play(my_play_map, his_play_map) :
    global order
    order = str()
    i_timer()
    if surface_decision(my_play_map) : 
        order = 'SURFACE'
        sector = tile_sector_converter(my_play_map['position'])
        my_play_map = surface_play_map(my_play_map, sector)
    else :
        # pas bien fait parce qu'on modifie direction path, position ... avant d'avoir appliquer l'order.
        # move
        my_play_map = next_tile(my_play_map)
        order =  f"MOVE {dir_converter(*my_play_map['next_direction'])} "
        # power
        order += power_decision(my_play_map, his_play_map)
        # torpedo
        torpedo, my_play_map = torpedo_decision(my_play_map, his_play_map)
        if torpedo : order += torpedo
        # mine
        order += mine_decision()
        # message
        order += add_message(my_play_map, his_play_map)
        # sonar
        my_play_map = sonar_decision(my_play_map, his_play_map) 
        if my_play_map['sonar'] : order += f" | SONAR {my_play_map['sonar']}"
        # evaluer silence
        my_play_map = silence_decision(my_play_map, his_play_map)
        
    if DEBUG : print(f"my order  : '{order}' ({round(perf_counter()-i_time,3)})")
    else : print(order)
    my_play_map = update_play_map(my_play_map, his_play_map)
    return  my_play_map

def surface_decision(play_map) :
    neighbor_tiles = update_path(play_map['position'], tools['manhattan'])
    surface = True
    for tile in neighbor_tiles :
        if not blocking(tile, play_map,  lap) : surface = False
    return surface

def power_decision(my_play_map, his_play_map) :
    silence_power = False if my_play_map['search_size'] > FLOOR['silence_pwr'] else True
    torpedo_power = False if my_play_map['search_size'] > FLOOR['torpedo_pwr'] else True
    if silence_power and my_play_map['silence_cooldown'] > 0 : power = 'SILENCE'
    elif torpedo_power and my_play_map['torpedo_cooldown'] > 0 : power = 'TORPEDO'
    elif my_play_map['sonar_cooldown']   > 0 : power = 'SONAR'
    elif my_play_map['silence_cooldown'] > 0 : power = 'SILENCE'
    elif my_play_map['torpedo_cooldown'] > 0 : power = 'TORPEDO'
    elif my_play_map['mine_cooldown']    > 0 : power = 'MINE'
    else : power = ''
    return f"{power}"

def torpedo_decision(my_play_map, his_play_map) :
    order = ''
    if his_play_map['search_size'] < FLOOR['torpedo'] and my_play_map['torpedo_cooldown'] == 0 :
        torpedo = torpedo_area(my_play_map['position'])
        torpedo_target = []
        for tile in his_play_map['search_area'] :
            if tile in torpedo : torpedo_target.append(tile)
        if torpedo_target :
            shoot_tile = random.choice(torpedo_target)
            ttx, tty = shoot_tile
            if type(ttx) is not int or type(tty) is not int : raise Exception("i_play()/torpedo_target : not int")
            order = f" | TORPEDO {ttx} {ttx}"
            my_play_map['sector_tiles'].update({lap : shoot_tile})
    return order, my_play_map

def mine_decision() :
    return ''

def sonar_decision(my_play_map, his_play_map) :
    if my_play_map['sonar_cooldown'] > 0 : sector = 0
    else :
        if his_play_map['search_size'] > FLOOR['sonar'] :
            sector = tile_sector_converter(random.choice(his_play_map['search_area']))
        else :
            sector = stat.mode(list(map(lambda tile : tile_sector_converter(tile), his_play_map['search_area'])))
    my_play_map.update({'sonar' : sector})
    return my_play_map

def silence_decision(play_map, opp_play_map) :
    play_map['silence'] = False if play_map['silence_cooldown'] != 0 else True
    return play_map

" PLAY MAP"

def init_play_map(me, start) :
    play_map = {'me'                        : me,
                'main'                      : True, # 'main' : his_play_map, my_play_map / temp : temp_play_map
                'start'                     : start,

                'direction_path'            : list(),
                'direction_path_length'     : int(),
                'direction_path_extending'  : tuple(),
                'fork'                      : list(),
            
                'next_direction'            : list(),
                
                'silence'                   : False,
            
                'sector_in'                 : dict(),
                'sector_out'                : dict(),
                'sector_tiles'              : dict(),
            
                'search_map'                : {key : 1 for key in MAP['sea']},
                'search_area'               : MAP['sea'],
                'search_size'               : MAP['sea_size'],
                'scatter'                   : float(),
            
                'life'                      : int(),
                
                'keys_list'                 : list()}
            
    if me or DEBUG:
        play_map.update({'torpedo_cooldown'          : COOLDOWN['torpedo'],
                         'sonar_cooldown'            : COOLDOWN['sonar'],    
                         'silence_cooldown'          : COOLDOWN['silence'],
                         'mine_cooldown'             : COOLDOWN['mine'],
                         'sonar_result'              : str(),
                         'sonar'                     : int(),

                         'target'                    : int(),
                         'opp_heat_map'              : dict(),
                         'position'                  : tuple(),
                         'last_tiles'                : list(),
                
                         'next_direction_path'       : list(),
                         'max_length_direction_path' : int()})
    
    if not me : 
        play_map.update({'order'                     : str()})
    play_map['keys_list'] = list(play_map)
    return play_map

def config_temp_play_map(play_map, position, next_direction_path, next_direction) :
    "just a format for evaluate_dir_map()"
    direction_path = [*play_map['direction_path'], *next_direction_path]
    temp_play_map =  {  'main'                          : False,
                        'start'                         : play_map['start'],
                        'position'                      : position,
                        
                        'next_direction'                : next_direction,
                        'next_direction_path'           : next_direction_path,
                        'next_direction_path_length'    : len(next_direction_path),
                        'next_direction_path_extending' : extending(next_direction_path),
                        
                        'direction_path'                : direction_path,
                        'direction_path_length'         : len(direction_path),
                        'direction_path_extending'      : extending(direction_path),
                        
                        'search_map'                    : dict(),
                        'search_area'                   : list(),  # play_map['search_area'],
                        'search_size'                   : list(),  # play_map['search_size'],
                        'scatter'                       : float(),
                        'value'                         : int(),
                        
                        'keys_list'                     : list()}
    temp_play_map['keys_list'] = list(temp_play_map)
    return temp_play_map

def surface_play_map(play_map, sector) :
    play_map.update({  'next_direction'  : [(0,0)],
                       'direction_path'  : list(),
                       'sector_in'       : {lap : sector},
                       'sector_out'      : dict(),
                       'sector_tiles'    : dict()})
    if play_map.get('last_tiles') :
        play_map.update({'last_tiles' : list()})
    return play_map

def update_play_map(play_map, opp_play_map) :
    # checking :
    for key in play_map : 
        if key not in play_map['keys_list'] : raise Exception(f"unknown keys in play_map : {key}")
    if type(play_map['me']) is not bool     : raise Exception(f"{play_map['me']} is not valid")
    if type(play_map['main'])  is not bool  : raise Exception(f"{play_map['main']} is not valid")
    if type(play_map['start']) is not bool  : raise Exception(f"{play_map['start']} is not valid")
    
    if DEBUG :
        play_map['position'] = add_tuple(play_map['position'], play_map['next_direction'])
    
    if not play_map['silence'] : 
        next_direction = play_map['next_direction']
        reversed_direction = reverse_direction(next_direction)
        play_map['direction_path'].insert(0, reversed_direction)
    else :
        play_map['direction_path'].insert(0, tools['silence_tiles'])
        play_map['silence'] = False
    
    play_map['next_direction'] = tuple()
    
    play_map.update({
    'direction_path_length'    : len(play_map['direction_path']),
    'direction_path_extending' : extending(play_map['direction_path']),
    'fork'                     : list(idx for idx,dir_ in enumerate(play_map['direction_path']) if len(dir_)>1) })
    
    play_map = config_search_map(play_map)
    
    if play_map['me'] or DEBUG :
        play_map['target'] = config_target(play_map, opp_play_map)
        play_map['opp_heat_map'] = config_heat_map(opp_play_map)
    
    if play_map['me'] or DEBUG:
        if play_map['position'] not in play_map['last_tiles'] : play_map['last_tiles'].append(play_map['position'])
    
    return play_map

" NEXT TILE"

def next_tile(play_map) :
    try_, test_value, value = 0, -1, -1
    metrics, test = {}, {}
    open_1 = True
    while open_1 == True :
        open_2 = test_time(play_map, main = False)
        while open_2 == True :
            temp_play_map = random_path(play_map)
            
            length_ratio = temp_play_map['next_direction_path_length'] / NUM['length']
            max_time = TIME['start'] if play_map['start'] == True else TIME['turn']
            time_ratio = (perf_counter() - i_time) / max_time
            open_2 = length_ratio < time_ratio and test_time(temp_play_map)
        
        try :
            temp_play_map = evaluate_dir_map(play_map, temp_play_map)
            
            test_value, metrics, test = next_tile_recorder(test_value, try_, temp_play_map, metrics, test)
            
            if temp_play_map['next_direction_path_length'] > play_map['max_length_direction_path'] : 
                play_map['max_length_direction_path'] = temp_play_map['next_direction_path_length'] 
    
            if temp_play_map['value'] > value :
                value = temp_play_map['value']
                play_map['next_direction_path'] = temp_play_map['next_direction_path']
                play_map['next_direction']      = temp_play_map['next_direction']
                ref_search_area                 = temp_play_map['search_area']
            try_ += 1
            open_1 = test_time(temp_play_map)
    
        except : break
    
    if not play_map['start'] :
        play_map = next_tile_security(play_map)

    
    if TEST['next_tile'] : return metrics
    if DSPL['search_map'] and play_map['me'] : display_search_map(test)
    if DSPL['path'] and play_map['me'] : display_path(test)
    
    if play_map['start'] : 
        play_map['position'] = random.choice(ref_search_area)
        play_map['last_tiles'].append(play_map['position'])
    return play_map

def random_path(play_map) :
    direction = [ [(1,0)], [(-1,0)], [(0,1)], [(0,-1)] ]
    onset_tile = play_map.get('position') if play_map.get('position') else random.choice(play_map['search_area'])
    
    open_1 = True
    while open_1 == True :
        current_direction_path = []
        temp_direction = [(0,0)]
        first_direction = None
        counter = 0
        current_tile = onset_tile
        current_tile_path = [current_tile]
        open_2 = True
        while open_2 == True :
            temp_direction = random.choice(direction)
            temp_tile = add_tuple(current_tile, temp_direction)
            if temp_tile not in current_tile_path and not blocking(temp_tile, play_map) :
                if first_direction == None : first_direction = temp_direction
                current_direction_path.append(temp_direction)
                current_tile = temp_tile
                current_tile_path.append(current_tile)
                counter = 0
                if len(current_direction_path) == NUM['length'] : open_2, open_1 = False, False
            else :
                if not test_time(play_map, main = False) : open_2, open_1 = False, False
                counter += 1
                if counter > 6 :
                    if first_direction != None : open_2, open_1 = False, False
                    else : open_2 = False
    
    return config_temp_play_map(play_map, onset_tile, current_direction_path, first_direction)


def evaluate_dir_map(play_map, temp_play_map) :

    temp_play_map = config_search_map(temp_play_map)
    hiding_value = scatter(temp_play_map)
    hunting_value = hunting(temp_play_map, play_map)
    temp_play_map['value'] = round( (1-play_map['target']) * hiding_value + play_map['target'] * hunting_value, 2)
    return temp_play_map

def config_target(play_map, opp_play_map) :
    life_ratio =    play_map['life']       / (opp_play_map['life'] + play_map['life'] )
    try : scatter_ratio = play_map['scatter']    / (opp_play_map['scatter'] + play_map['scatter'])
    except ZeroDivisionError : scatter_ratio = 0
    return round((0.5 * life_ratio + scatter_ratio) / 1.5 , 2)

def config_heat_map(opp_play_map) :
    sm_mean = 1 - opp_play_map['scatter']
    opp_heat_map = copy.deepcopy(opp_play_map['search_map'])
    coef = 1 / ( NUM['heat_map'] * 4)
    for repetition in range(NUM['heat_map']) :
        for key in MAP['sea'] :
            cursor_list = update_path(key, tools['manhattan'])
            for cursor in cursor_list :
                if opp_heat_map.get(cursor) : opp_heat_map[cursor] += opp_heat_map[key] * coef
                else : opp_heat_map[key] += sm_mean * coef
            opp_heat_map[key] += opp_play_map['search_map'][key] * coef
            if repetition == NUM['heat_map'] - 1 or not test_time(heat_map = True)  : 
                opp_heat_map[key] = round(opp_heat_map[key], 2)
                return opp_heat_map 

def scatter(temp_play_map) :
    spread_list = []
    sector_list = []
    for key in temp_play_map['search_map'] :
        sector_list.append(tile_sector_converter(key))
        if temp_play_map['search_map'][key] == 1 :
            cursor_list = [add_tuple(key, tiles) for tiles in tools['euclidean']]
            count = 0
            for cursor in cursor_list :
                try : temp_play_map['search_map'][cursor]
                except KeyError : continue
                if temp_play_map['search_map'][cursor] == 1 : count += 1
                spread_list.append(1 - (0.1 * count) if count >= 2 else 1)
    sector_value = math.log(len(set(sector_list)) + 1, 10)
    length_value = math.sin(temp_play_map['next_direction_path_length'] * (math.pi / 2) / NUM['length'])
    try : spread_value = stat.mean(spread_list)
    except : spread_value = 0
    try : scatter_value = stat.mean(list(temp_play_map['search_map'].values()))
    except : scatter_value = 0
    return 0.30*spread_value + 0.30*sector_value + 0.15*length_value + 0.25*scatter_value

def hunting(temp_play_map, play_map) :
    if play_map['me'] and (not play_map['opp_heat_map'] or not temp_play_map['next_direction_path']) : return 0
    if not play_map['me'] and DEBUG and (not play_map['opp_heat_map'] or not temp_play_map['next_direction_path']) : return 0
    hunting_value = []
    tile_path = update_path(temp_play_map['position'], temp_play_map['next_direction_path'])
    for tile in tile_path :
        if play_map['opp_heat_map'].get(tile) : hunting_value.append(play_map['opp_heat_map'][tile])
    return stat.mean(hunting_value)

def next_tile_security(play_map) :
    global DFLT
    if play_map['next_direction'] : return play_map
    else :
        DFLT['next_tile_security'] = True
        for direction in tools['manhattan'] :
            tile = add_tuple(play_map['position'], direction)
            if not blocking(tile) :
                play_map['next_direction'] = direction
                return play_map

" SEARCH MAP"

def config_search_map(play_map) :        
    positiv_result, tested_tile = 0, 0
    poll_rate = NUM['sampling']
    play_map['search_area'] = MAP['sea']
    play_map['search_size'] = MAP['sea_size']
    temp_search_area = []
    while True :
        
        non_tested, sample = sampling(play_map)
        
        for tile in sample :
            tested_tile += 1
            result = run_path(tile, play_map)
            play_map['search_map'][tile] = result
            positiv_result += result
            if result : temp_search_area.append(tile)
        probability = round(positiv_result / tested_tile, 2)
        
        if probability > 1 - poll_rate or not non_tested :
            for tile in non_tested : play_map['search_map'][tile] = probability
            play_map['search_area'] = [*temp_search_area, *non_tested]
            play_map['search_size'] = len(play_map['search_area'])
            play_map['scatter'] = 1 - probability
            return play_map
        else :
            play_map['search_area'] = non_tested
            play_map['search_size'] = len(play_map['search_area'])
            poll_rate += NUM['sampling']

def sampling(play_map) :
    if play_map['start'] or play_map['search_size'] < FLOOR['sampling'] or not OPT['sampling'] :
        non_tested, sample = [], play_map['search_area']
    else : non_tested, sample  = train_test_split(play_map['search_area'], test_size = FLOOR['sampling'])
    return non_tested, sample

def run_path(tile, play_map) :
    if off_side_max(tile, play_map['direction_path_extending']) and not TEST['random_path'] : return 0.00 
    fork_map = copy.deepcopy(config_fork_map(play_map))
    cursor = initial_cursor(play_map, fork_map, tile)    
    controller = {'blocking' : False,  'end_path' : False, 'stop' : True}
    search_map = 0.00 # possible path for this tile
    while True :
        "A : embranchement : "
        if fork_map['fork'].get(cursor['idx']) != None :
            fork_map = update_fork_map(cursor['idx'], fork_map)
            controller['stop'] = stop(fork_map)
        "B : obstacle : " 
        controller['blocking'] = blocking(cursor['tile'], play_map, cursor['lap'])
        "C : bout de path : " 
        controller['end_path'] = True if cursor['idx'] == play_map['direction_path_length'] - 1 else False

        if DSPL['run_path'] : display_run_path(controller, cursor, fork_map, tile)
            
        if controller['end_path'] == True and controller['blocking'] == False : 
            if OPT['one_path'] : return 1.00
            else : search_map += 1.00
        
        if controller['stop'] == False :
            if controller['blocking'] == True or controller['end_path'] == True :
                cursor = initial_cursor(play_map, fork_map, tile)
                continue
        else :
            if controller['blocking'] == True or controller['end_path'] == True :
                return search_map
        cursor = update_cursor(cursor, play_map, fork_map)

# cursor

def initial_cursor(play_map, fork_map, tile) :

    direction = ( play_map['direction_path'][0][fork_map['fork'][0]-1] 
                  if fork_map['fork'].get(0) != None
                  else play_map['direction_path'][0][0] )

    return {'idx' : int(),
            'lap' : lap if play_map['main'] else None,  
            'dir' : direction,
            'tile' : add_tuple(tile, direction) }


def update_cursor (cursor, play_map, fork_map) :
    cursor['idx'] += 1
    cursor['lap'] = lap - cursor['idx'] if play_map['main'] else None
    branch_index = (fork_map['fork'][cursor['idx']] 
                    if fork_map['fork'].get(cursor['idx']) != None
                    else 0)
    cursor['dir'] = play_map['direction_path'][ cursor['idx'] ] [branch_index]
    cursor['tile'] = add_tuple(cursor['tile'], cursor['dir'])
    return cursor

def stop(fork_map) :
    if len(fork_map['fork']) != len(fork_map['max']) : 
        raise ValueError('fork_map')
    if (len(fork_map['fork']) == 1 and 
        list(fork_map['fork'].values()) == list(fork_map['max'].values())) :
        return True
    else : return False

# fork_map

def config_fork_map (play_map) :
    # how fork_map is built :
    fork_map = {'fork' : {}, 'max' : {}, 'fork-index': {}, 'index-fork' : {}}
    if play_map.get('fork') :
        index = 0
        for fork in play_map['fork'] :
            fork_map['fork'][fork] = 0
            fork_map['max'][fork] = len(play_map['direction_path'][fork])
            fork_map['fork-index'][fork] = index
            fork_map['index-fork'][index] = fork
            index += 1
    return fork_map

def del_fork_map (fork_map, fork) :
    index = fork_map['fork-index'][fork] 
    for cursor in ['fork', 'max', 'fork-index'] : del fork_map[cursor][fork]
    del fork_map['index-fork'][index]
    return fork_map

def update_fork_map(fork, fork_map): 
    fork_map['fork'][fork] += 1
    while fork_map['fork'][fork] > fork_map['max'][fork] :
        index = fork_map['fork-index'][fork]
        index -= 1 if index - 1 >= 0 else 0
        fork_map = del_fork_map(fork_map, fork)
        try :
            fork = fork_map['index-fork'][index]
            fork_map['fork'][fork] += 1    
        except KeyError : break
    return fork_map

" GAME MAP"

def config_map() :
    global i_start, MAP
    tiles, island, sea = [], [], []
    if not DEBUG :
        width, height, my_id = [int(i) for i in input().split()]
        if MAP['size'] != width or MAP['size'] != height : raise Exception('size != 15')
        size = MAP['size']
        for y in range(size):
            line = input()
            for x in range(size) :
                tile = (x,y)
                tiles.append(tile)
                if line[x] == 'x'  : island.append(tile)
                else : sea.append(tile)
    elif not DFLT['check_search_map'] and TEST['random_path'] :
        size = 7
        my_id = 0
        sea = [(1,1),(1,2),(1,3),(2,3),(3,3),(3,4),(3,5),(3,6),(4,6),(5,6),(6,6),(7,6),(7,7)]
        island = [(x,y) for x in range(size) for y in range(size) if (x,y) not in sea]
        tiles = [*sea, *island]
    else : 
        size = MAP['size']
        my_id = random.randint(0,1)
        weights = [normal_law(i,s2=5,mu=20) for i in range(40)] 
        tiles = [(x,y) for x in range(size) for y in range(size)]
        if DFLT['check_search_map'] :
            island = [(x,y) for x in range(6,9) for y in range(6,9)]
        else :
            num_island = random.choices([i for i in range(40)], weights)
            island = random.sample(tiles, *num_island)
        sea = [xy for xy in tiles if xy not in island]
    if SHOW['island'] and DEBUG and not DFLT['check_search_map'] : print(f"island : {island}")
    i_start = True if not my_id else False
    MAP.update({'tiles' : tiles, 'island' : island, 'sea' : sea, 'sea_size' : len(sea)})

" TOOLS"

def config_global_var():
    global tools
    tools = {'manhattan'      : [[(1,0)], [(-1,0)], [(0,1)], [(0,-1)]],
             'euclidean'      : [(-1,-1),(-1,0),(-1,1),(0,-1),(0,1),(1,1),(1,0),(1,-1)],
             'silence_tiles'  : list(set([(x,0) for x in range(-4,5) if x != 0] + [(0,y) for y in range(-4,5) if y != 0])),
             'torpedo_tiles'  : [(x,y) for x in range(-4, 5) for y in range(-4, 5) if abs(x) + abs(y) <= 4 and (x != 0 or y!= 0)]
            }
    return tools

# time

def init_timer() :
    global gt_recorder, it_recorder, dt_recorder
    gt_recorder = list()
    it_recorder = list()
    dt_recorder = list()
    
def g_timer(*command):
    global g_time
    if   'end'    in command : g_time = perf_counter() - g_time 
    elif 'record' in command : print(round(perf_counter() - g_time),2)
    elif 'print'  in command  and DEBUG : print(f"g_timer : {round(perf_counter() - g_time, 2)}")
    else : g_time = perf_counter()

def i_timer(*command):
    global i_time
    if   'end'    in command : i_time = perf_counter() - i_time 
    elif 'record' in command : print(round(perf_counter() - i_time),2)
    elif 'print'  in command and DEBUG : print(f"i_timer : {round(perf_counter() - i_time, 2)}")
    else : i_time = perf_counter()

def d_timer(*command) :
    global d_time
    if   'end'    in command : d_time = perf_counter() - i_time 
    elif 'record' in command : print(round(perf_counter() - d_time),2)
    elif 'print'  in command and DEBUG : print(f"d_timer : {round(perf_counter() - d_time, 2)}")
    else : d_time = perf_counter()

def test_time(play_map = None, main = None, start = None, heat_map = False) :
    if play_map and main == None : main = play_map['main'] 
    if play_map and start == None : play_map['start'] 
    
    if main and start :
        test = perf_counter() - i_time < TIME['start_limit'] 
        if not test : raise Exception(f'time_out : {perf_counter() - i_time}')
    elif main and not start:
        test = perf_counter() - i_time < TIME['turn_limit']
        if not test : raise Exception(f'time_out : {perf_counter() - i_time}')
    elif not main and start :
        test = perf_counter() - i_time < TIME['start'] 
    elif not main and not start and not heat_map :
        test = perf_counter() - i_time < TIME['turn']
    elif heat_map : 
        test = perf_counter() - i_time < TIME['heat_map']
    return test
    
# direction_path

def add_tuple(tuple_1, tuple_2) :
    if type(tuple_1) is list and len(tuple_1) == 1 : tuple_1 = tuple_1[0]
    if type(tuple_2) is list and len(tuple_2) == 1 : tuple_2 = tuple_2[0] 
    return tuple_1[0] + tuple_2[0], tuple_1[1] + tuple_2[1]

def reverse_direction(direction) :
    if type(direction) is list and len(direction) == 1 :
        direction = direction[0]
    return [(direction[0] * -1 , direction[1] * -1)]

def dir_converter(key) :
    # NB : can't put list of tuple as key
    if type(key) is list and len(key) == 1 : key = key[0]
    dir_dic = { (-1, 0) : 'W', 'W' : [(-1, 0)],
                ( 1, 0) : 'E', 'E' : [( 1, 0)],
                ( 0,-1) : 'N', 'N' : [( 0,-1)],
                ( 0, 1) : 'S', 'S' : [( 0, 1)] }
    return dir_dic[key]

def update_path(tile=(0,0), path = []) :    
    return [tile, *list(map(lambda xy : add_tuple(tile, xy), path))]

# direction path with map

def extending(direction_path) :
    e_w = sum([xy[0][0] for xy in direction_path if len(xy) == 1]) 
    n_s = sum([xy[0][1] for xy in direction_path if len(xy) == 1]) 
    return e_w, n_s

def off_side_max(tile, direction_path_extending) :
    size = MAP['size']
    e_w, n_s = direction_path_extending
    e_w += tile[0]
    n_s += tile[1]
    if DFLT['check_search_map'] : return False
    else : return (e_w not in range(0,size) or n_s not in range(0,size))

def off_side_tile (tile) :
    size = MAP['size']
    if len(tile) != 2 : raise Exception(f'not tuple in off_side_tile() {tile}')
    x,y = tile
    return (x not in range(0,size) or y not in range(0,size))

def tile_sector_converter(xy) :
    sector = {'1': [ 0, 5, 0, 5], '4' : [ 0, 5, 5,10], '7' : [ 0, 5,10,15],
              '2': [ 5,10, 0, 5], '5' : [ 5,10, 5,10], '8' : [ 5,10,10,15],
              '3': [10,15, 0, 5], '6' : [10,15, 5,10], '9' : [10,15,10,15]}
    for i in '123456789' :
        if sector[i][0] <= xy[0] < sector[i][1] and sector[i][2] <= xy[1] < sector[i][3] : 
            return int(i)

def normal_law(x,s2,mu): # nouveau
    sigma = math.sqrt(s2)     
    return (1 / (sigma * math.sqrt(2 * math.pi))) * math.exp((-1 / 2) * (((x - mu)/sigma) ** 2))

def blocking(tile, play_map = None, index = None) :
    blocking = tile in MAP['island'] or off_side_tile(tile)
    if not blocking and play_map and play_map.get('last_tiles') :
        blocking = tile in play_map.get('last_tiles')  
    if not blocking and play_map and play_map['main'] :
        current_sector = tile_sector_converter(tile)
        if not blocking and play_map['sector_in'].get(index) :
            blocking =  play_map['sector_in'].get(index) != current_sector
        if not blocking and play_map['sector_out'].get(index) :
            blocking = current_sector == play_map['sector_out'].get(index)
        if not blocking and play_map['sector_tiles'].get(index) :
            blocking = tile not in play_map['sector_tiles'].get(index)
    return blocking

# sector and area

def torpedo_area(ref_position) :
    if type(ref_position) is not tuple : raise Exception('bad settings')
    path = [ref_position]
    range_ = 0
    torpedo_area = []
    while True :
        run = False
        for cursor in update_path(path[-1], tools['manhattan']) :
            if cursor in torpedo_area or blocking(cursor) or range_ == MAP['torpedo'] : continue
            else :
                run = True
                range_ += 1
                path.append(cursor)
                torpedo_area.append(cursor)
                break
        if not run :
            if path[-1] is ref_position : 
                torpedo_area.remove(ref_position)
                return torpedo_area
            range_ -= 1
            path.pop(-1)

"MESSAGE CONTEXT"

def add_message(my_play_map, his_play_map) :
    global DFLT
    if MESSAGE : 
        order = " | MSG "
        if MSG['his_search_map'] : order += f"SM{his_play_map['search_size']} "
        if DFLT['next_tile_security']: 
            order += "SECU "
            DFLT['next_tile_security'] = False
        if order == " | MSG " : order = ''
    else : order = ''
    return order

"DEBUG" 

def loop(my_play_map, his_play_map) :
    if DEBUG and lap == NUM['laps'] : 
        temp = {tile : 'X' if tile in MAP['island'] else '_' for tile in MAP['tiles']}
        temp.update({val : idx for idx, val in enumerate( my_play_map['last_tiles'])})
        temp.update({val : idx for idx, val in enumerate(his_play_map['last_tiles'])})
        if SHOW['path'] : print_map(temp)
        return True

def print_map(map_) :
    for x in range(MAP['size']) :
        line = []
        for y in range(MAP['size']) :
            line.append(map_[x,y])
        print(*line, sep = ' ')

def create_input(my_play_map, his_play_map) :
    if i_start == True and lap == 0 : order = 'NA'
    elif surface_decision(his_play_map) or random.choices([True,False], [1,20])[0] :  
        order = f"SURFACE {tile_sector_converter(his_play_map['position'])}"
    else :
        his_play_map = next_tile(his_play_map)
        order = f"MOVE {dir_converter(*his_play_map['next_direction'])} SILENCE"
        his_play_map = silence_decision(his_play_map, my_play_map)
        if his_play_map['silence'] : order += ' | SILENCE N 0'
    
    input_ = { 'position'         : my_play_map['position'],
               'my_life'          : random.randint(1,6) if not my_play_map['life'] else my_play_map['life'],
               'opp_life'         : random.randint(1,6) if not his_play_map['life'] else his_play_map['life'],
               'torpedo_cooldown' : my_play_map['torpedo_cooldown'],
               'sonar_cooldown'   : my_play_map['sonar_cooldown'],
               'silence_cooldown' : my_play_map['silence_cooldown'],
               'mine_cooldown'    : my_play_map['mine_cooldown'],
               'sonar_result'     : 'NA',
               'his_order'        : order }
    return input_

def next_tile_recorder(test_value, try_, temp_play_map, metrics, test) :
    if TEST['next_tile'] or DSPL['search_map'] or DSPL['path'] :
        if temp_play_map['value'] > test_value :
            test_value = temp_play_map['value']
            time_ = perf_counter() - i_time
            metrics = {'direction_path' : temp_play_map['direction_path'], 'path_value' : temp_play_map['value'], 
                       'process_time' : time_, 'path_length' :temp_play_map['direction_path_length'], 
                       'swing_turn' :  try_ }
            test = {'direction_path' : temp_play_map['direction_path'], 
                    'search_map' : temp_play_map['search_map'], 
                    'search_size' : temp_play_map['search_size'],
                    'scatter' : temp_play_map['scatter']}
                    # laisser scatter
        metrics.update({'total_turn' : try_, 'total_time' : perf_counter() - i_time}) 
    return test_value, metrics, test

# check

def check_search_map() :
    if not DEBUG : return
    global lap, DFLT, OPT
    lap = 0
    OPT['sampling'] = False
    DFLT['check_search_map'] = True
    if DSPL['check_search_map'] : OPT['game_loop'] = False
    config_map()
    
    test_list = {}
    true_result = { 
        'surface'    : {  xy   : 1 if tile_sector_converter(xy) == 2 else 0 for xy in MAP['sea'] },
        'sector_out'   : {  xy   : 0 if tile_sector_converter(xy) == 2 else 1 for xy in MAP['sea'] },
        'torpedo'      : {  xy   : 1 if xy in torpedo_area((10,7)) else 0 for xy in MAP['sea'] },
        'silence'      : silence_result(),
        'E'            : { (x,y) : 0 if x != 0  or 5 < y < 9 else 1 for x,y in MAP['sea'] },
        'W'            : { (x,y) : 0 if x != 14 or 5 < y < 9 else 1 for x,y in MAP['sea'] },
        'S'            : { (x,y) : 0 if y != 0  or 5 < x < 9 else 1 for x,y in MAP['sea'] },
        'N'            : { (x,y) : 0 if y != 14 or 5 < x < 9 else 1 for x,y in MAP['sea'] }}
    
    label_list = list(true_result)
    value_list = ['sector_in', 'sector_out', 'torpedo', 'silence', *tools['manhattan']]
    cursor_list = list(zip(label_list, value_list))
    for label, value in cursor_list :
        test_play_map = init_play_map(me = True, start = False)
        if label in ['surface', 'sector_out', 'torpedo'] :
            direction_path =  [[(0,0)]]
            if label in ['surface', 'sector_out'] : test_play_map[value] = {lap : 2}
            elif label == 'torpedo' : test_play_map['sector_tiles'] = {lap : torpedo_area((10,7))}
        elif label == 'silence' :
            direction_path = [[(1,0)] for _ in range(MAP['size'] - 1) ]
            direction_path.insert(0, tools['silence_tiles'])
        else : direction_path = [value for _ in range(MAP['size'] - 1) ]
        test_play_map['direction_path'] = direction_path
        test_play_map['fork'] = list(idx for idx,dir_ in enumerate(test_play_map['direction_path']) if len(dir_)>1)
        test_play_map['direction_path_length'] = len(direction_path)
        test_play_map['direction_path_extending'] = extending(direction_path)
            
        test_play_map = config_search_map(test_play_map)
        
        test = all( true_result[label][tile] == test_play_map['search_map'][tile] 
                   for tile in test_play_map['search_map'])
        if DSPL['check_search_map'] : 
            print(f"test {label} : {test}\n")
            display_search_map(test_play_map)
        else : 
            test_list[label] = test
    if all(test_list.values()) : 
        print('check_search_map\n')
        DFLT['check_search_map'] = False
        OPT['sampling'] = True
    else : raise Exception(f"check_search_map : {test_list}")
 
def silence_result() :
    silence_result = {}
    for x,y in MAP['sea'] :
        if OPT['one_path'] :
            if x == 0 : silence_result.update({(x,y) : 1})
            elif 0 < x < 5 and (y < 6 or 8 < y) : silence_result.update({(x,y) : 1})
            else : silence_result.update({(x,y) : 0})
        else :
            if x == 0 :
                if   y in [0, 14]   : silence_result.update({(x,y) : 4})
                elif y in [6, 7, 8] : silence_result.update({(x,y) : 6})
                else :                silence_result.update({(x,y) : 5})
            elif x < 5 and (y < 6 or 8 < y) : silence_result.update({(x,y) : 1})
            else :       silence_result.update({(x,y) : 0})
    return silence_result

def test_random_path() :
    play_map = init_play_map(me = True, start = False)
    play_map['position'] = (1,1)
    count = 1
    while True : 
        test_play_map = random_path(play_map)
        if len(test_play_map['next_direction_path']) == 10 : break 
    print(test_play_map['next_direction_path'])
    test_play_map['position'] = (1,1)
    test_tile_path = update_path(test_play_map['position'], test_play_map['next_direction_path'])
    
    for x in range(MAP['size']) :
        line = []
        for y in range(MAP['size']) :
            if (x,y) in test_tile_path : 
                line.append(f'{count}')
                count += 1
            elif (x,y) in MAP['island'] : line.append('x')
            else : line.append('_')
        print(*line, sep = ' ')

# debug

def display_search_map(test_play_map) :
    """
    give graphics overview of the value of each tiles, content is a dic with tuple (x,y) as key
    At start next_tiles function make a direction_path ('direction_path') and seek where this direction
    path can start on the map. This is the graphic result. 
    In game loop show where the submarine could be on the map 
    """

    print("display_search_map in next_tile()")
    for y in range(MAP['size']):
        line = []
        for x in range(MAP['size']):
            try : line.append(f"_{int(test_play_map['search_map'][x,y])}" 
                              if test_play_map['search_map'][x,y] >= 1 or test_play_map['search_map'][x,y] == 0
                              else f"{int(test_play_map['search_map'][x,y]*100):02}")
            except KeyError : line.append('XX')
        print(*line, sep=' ') 
    print(f"positive rate : {test_play_map['scatter']} sample_size : {test_play_map['search_size']}\n")
    # laisser scatter
    return

def display_path(test_play_map) :
    if DSPL['path'] : print("display_path")
    tile_cursor = (0,0)
    path_cursor = [tile_cursor]
    for direction in test_play_map['direction_path'] :
        tile_cursor = add_tuple(tile_cursor, direction[0])
        path_cursor.append( tile_cursor)
    
    min_x = min([xy[0] for xy in path_cursor])
    min_y = min([xy[1] for xy in path_cursor])
    correction = -min_x, -min_y
    path_cursor = update_path(correction, path_cursor)
    path_cursor = { key : value for value,key in enumerate(path_cursor) }
    max_x = max([xy[0] for xy in path_cursor])
    max_y = max([xy[1] for xy in path_cursor])
    spread = round( abs(max_x - min_x) * abs(max_y - min_y) / (MAP['size']**2) , 2)
    spread_length = round( abs(max_x - min_x) * abs(max_y - min_y) / len(path_cursor)**2 , 2)
    
    if DSPL['path'] :
        for y in range(max_y + 1) :
            line = []
            for x in range(max_x + 1) :
                if (x,y) in path_cursor :
                    line.append(f'{path_cursor[(x,y)]:02}')
                else : line.append('__')
            print(*line, sep=' ')
    else : return spread, spread_length

def display_run_path(controller, cursor, fork_map, tile, cmd = '', r = '') :
        """ 
        Trace what occuring un run_path() which is the function where we test each tile without island
        to know if a given direction path could start or finish in this tile. When status is start we test 
        if it could start from the given tile. In game_loop it is finish. The function feed a variable always
        named search_map
        
        position in debug line:
        1           tile                      -> tile from which dir_ starts to sea
        2           cursor['idx']             -> index in dir_
        3           block/end_path            -> when blocking or end_path is true
        4 fork_map['fork']/fork_map['max']    -> main information on the situation in fork_map
        '_' if nothing
        OPTION : if cmd = 'cursor','fork_map', 'controller' print one or several contain
        """
        show = (max([controller['blocking'], controller['end_path']]),
                controller['blocking'],
                controller['end_path']) 
        fork_map_situation = [str(fork) + '/' + str(max_)
                              for fork in list(fork_map['fork'].values())
                              for max_ in list(fork_map['max'].values()) ]
        space = ' ' * 25 if tile[1] % 2 != 0 else '' # just to see more tile changing
        r += (space + str(tile)) * show[0]
        r += (' ' + str(cursor['idx'])) * show[0]
        r += (' ' + ('block')) * show[1]
        r += (' ' + ('end_path')) * show[2]
        r += (' ' + str(*fork_map_situation if fork_map_situation else '_'))* show[0]
        r += (' ' + str(controller['stop'])) * show[0]
        if  'fork_map' in cmd : r += (' ' + str(fork_map)) * show[0]
        if 'cursor' in cmd : r += (' ' + str(cursor)) * show[0]
        if 'controller' in cmd : r += (' ' + str(controller))* show[0]
        if r : print(r)
        else : pass

# test

def test_next_tile() :
    test_play_map = init_play_map(me = True, start = False)
    count = 0
    # memo
    secu = 0
    indicator = ['path_value', 'process_time', 'total_time', 'path_length', 'swing_turn', 
                 'total_turn', 'path_spread', 'spread_length_ratio']
    label = ['value', 'time', 'tot_time', 'length', 'turn', 'tot_turn', 'spread', 'sprd_lngth']
    color=  ['red', 'orange', ' ', 'blue', 'cyan', ' ', 'purple', ' ']
    label = dict(zip(indicator, label))
    color = dict(zip(indicator, color))
    metric = {key : [] for key in indicator}
    while count != NUM['test'] :
        i_timer()
        temp = next_tile(test_play_map) 
        for key in indicator : 
            try : metric[key].append(temp[key])
            except KeyError : pass
        spread, spread_length = display_path(temp)
        metric['path_spread'].append(spread)
        metric['spread_length_ratio'].append(spread_length)
        # memo
        if not temp['direction_path'] : secu += 1
        
        count += 1
    for key in metric : print(f'{label[key]:7s} : ({round(stat.mean(metric[key]), 2):.2f}, {round(stat.pstdev(metric[key]), 2):.2f}), ({color[key]})')
    print(f"secu : {secu}")
    
    import matplotlib.pyplot as plt
    turn = list(range(NUM['test']))
    fig, ax1 = plt.subplots(layout='constrained')
    ax1.plot(turn, metric['path_value'], color='tab:red')
    ax1.plot(turn, metric['process_time'], color='tab:orange')
    ax1.tick_params(axis='y', labelcolor='tab:red')
    ax2 = ax1.twinx()
    ax2.plot(turn, metric['path_length'], color='tab:blue')
    ax2.plot(turn, metric['swing_turn'], color='tab:cyan')
    ax2.plot(turn, metric['path_spread'], color='tab:purple')
    ax2.tick_params(axis='y', labelcolor='tab:blue')
    plt.show()

def test_heat_map() :
    pos_rat, test_rat, time_test, count = [], [], [], []
    print("time : blue", "tested_rate : red (optional)", "positive_rate : green (optional)",  sep="\n")
    
    for positive in range(10) :
        positive_odds = positive / 10
        for sample in range(10) :
            tested_odds = sample / 10
            
            tested_and_positive, non_tested = [], []
            opp_play_map = {'main' : True, 'start' : False, 'search_map' : {}, 'search_area' : [], 
                            'scatter' : int()}
            tested = 0
            positive_result = 0
            
            for tile in MAP['sea'] :  
                if random.choices([True,False], [tested_odds, 1 - tested_odds])[0] :
                    tested += 1
                    if random.choices([1,0], [positive_odds, 1 - positive_odds])[0] :
                        positive_result += 1
                        tested_and_positive.append(tile)
                        opp_play_map['search_map'][tile] = 1
                    else : opp_play_map['search_map'][tile] = 0
                else : non_tested.append(tile)
            
            try : positive_rate = round( positive_result / tested, 1)
            except : positive_rate = 0
            opp_play_map['scatter'] = 1 - positive_rate
            # comprend rien à revoir
            for tile in non_tested : opp_play_map['search_map'][tile] = positive_rate
            opp_play_map['search_area'] = [*tested_and_positive, *non_tested]
            
            i_timer()
            config_heat_map(opp_play_map)
            time_test.append( (perf_counter() - i_time))
            count.append(int( str(positive) + str(sample)))
            pos_rat.append(positive_rate)
            test_rat.append(tested / 225)
    
    import matplotlib.pyplot as plt
    fig, ax1 = plt.subplots(layout='constrained')
    ax1.plot(count, time_test, color = 'blue')
    ax2 = ax1.twinx()
    ax2.plot(count, pos_rat, color = 'green')
    ax2.plot(count, test_rat, color = 'red')
    plt.show()
    
    print(f"mean time : {round(stat.mean(time_test), 4)}, max time : {round(max(time_test), 4)}")

" START "

if __name__ == '__main__' : main()
