
def add (tuple_1, tuple_2, laps='',sector='') :
    if laps : return tuple_1[0] + tuple_2[0], tuple_1[1] + tuple_2[1], laps
    elif sector : return tuple_1[0] + tuple_2[0], tuple_1[1] + tuple_2[1], laps, sector
    else : return tuple_1[0] + tuple_2[0], tuple_1[1] + tuple_2[1]

def current_path(xy, path) : return list(map(lambda xy_path : add(xy, xy_path), path))

def sector (x,y) :
    sector = {'1': [0,5,0,5],  '2' : [0,5,5,10],  '3' : [0,5,10,15],
              '4': [5,10,0,5],  '5' : [5,10,5,10],  '6' : [5,10,10,15],
              '7': [10,15,0,5],'8' : [10,15,5,10],'9' : [10,15,10,15]}
    for i in '123456789' :
        if sector[i][0] <= x <= sector[i][1] and sector[i][2] <= y < sector[i][3] : return i
    return 'x'

def run_map(brows_map,path) : # brows_map designe une list de tuple sans les tuples des islands
    map_ = {}
    #for xy in brows_map :
    xy = (1,1)
    map_[xy] = run_path(xy, brows_map, path)
    return map_   

def run_path(start_tile,  brows_map, path): # nb : un seul 'sielence' possible
# list of list of tuples : [(x,y,laps,sector)],[()],[(),(),()],[()]
    possible_path = 0
    
    """    
    1 Pas d'embranchement'
        A Obstacle
        B Bout de path 
            a sans embranchement avant 
            b avec embranchement avant
        C Autre : next cursor, tile
    2 Avec embranchement
        A Premier embranchement 
            a Ostacle
            b : Autre : next cursor, tile
        B Dernière embranchement avec qqc après, obstacle :
            a dernière Branche
            b autre
        C Dernière embanchement en bout de path :
            a obstacle !!!
            b Dernière Branche
            c Autre
        D Autre embranchement avec obstacle

    Modifier :    

    1 Pas d'embranchement'
        A Obstacle
        B Bout de path 
            a sans embranchement avant 
            b avec embranchement avant
        C Autre : next cursor, tile
    2 Avec embranchement
        A Dernière embranchement avec qqc après, obstacle :
            a dernière Branche
            b autre
        B Dernière embanchement en bout de path :
            a obstacle
            b Dernière Branche
            c Autre
        C Autre embranchement [Tous sauf si dernier embranchement, a verifier]
            a avec obstacle   
            b Premier embranchement 
            c : Autre : next cursor, tile
    """

    junction = 'x'
    start_cursor, cursor, branch = 0, 0, 0
    tile = start_tile
    while True :
        if len(path[cursor]) == 1 :
            if add(path[cursor][0], tile) not in brows_map:
                print('1A Pas d embranchement , obstacle : fin')
                return possible_path
            elif cursor == len(path) :
                possible_path += 1
                if junction == 'x': # CONDITION SANS EMBRACNHEMENT
                    print('1Ba Bout de path sans embranchement avant : fin')
                    return possible_path
                else :
                    print('1Bb Bout de path avec embranchement avant : retour')
                    cursor = start_cursor
                    tile = start_tile
            else : 
                tile = add(path[cursor][0], tile)
                cursor = path[cursor][0][2]
                print(f' On avance cursor = {cursor}, tile = {tile}')
                
        else :
            junction = 'o'
            if all(len(k) == 1 for k in path[:cursor]) :
                if add(path[cursor][0], tile) not in  brows_map:
                    path[cursor].pop(0)
                    junction = 'x'
                    cursor = start_cursor
                    tile = start_tile
                    print('2Aa : premier embranchement, obstacle : retour')
                else : 
                    start_cursor = cursor
                    start_tile = tile
                    tile = add(path[cursor][0], tile)
                    cursor = path[cursor][0][2]
                    print('2Ab : premier embranchement, autre')
                    print(f' next cursor = {cursor}, tile = {tile}')
            try :
                # nécéssaire à cause du cursor + 1 ci_dessous
                if all(len(i) == 1 for i in path[cursor+1:]) and add(path[cursor][branch], tile) not in  brows_map :
                    path[cursor].pop(branch)
                    junction = 'x'
                    if branch == len(path[cursor]) - 1  : 
                        branch = 0
                        print('2Ba : dernière embranchement, dernière branche, obstacle : retour')
                    else : 
                        branch += 1
                        print('2Bb : dernière embranchement, autre branche, obstacle : retour')
                    cursor = start_cursor
                    tile = start_tile
            except IndexError : 
                # implique que l'on est en bout de path
                if add(path[cursor][branch], tile) not in  brows_map :
                    path[cursor].pop(branch)
                    junction = 'x'
                    # pas de branche+=1
                    print('2Cb : dernière embranchement, dernière branche, Bout de path et obstacle : retour')
                elif branch == len(path[cursor]) - 1 :
                    path[start_cursor].pop(0)
                    possible_path += 1
                    junction = 'x'
                    branch = 0
                    print('2Cb : dernière embranchement, dernière branche, Bout de path : retour')
                else : 
                    possible_path += 1
                    branch += 1
                    print('2Cc : dernière embranchement, autre branche, Bout de path : retour')
                cursor = start_cursor
                tile = start_tile

            else :
                if add(path[cursor][0], tile) not in  brows_map:
                    path[cursor].pop(0)
                    junction = 'x'
                    cursor = start_cursor
                    tile = start_tile
                    print('2D Avec embranchement, pas premier, pas dernier, obstacle : retour')
                    

def main():
    
    brows_map = [] # map de référence sans les îles
    island = []
    path = [[(-1,0,1)],[(0,1,2)],[(0,1,3)],[(1,0,4)],[(0,1,5)],[(1,0,6)],[(-3,0,7),(-2,0,7),(-1,0,7),(0,-3,7),(0,-2,7),(0,-1,7),(3,0,7),(2,0,7),(1,0,7),(0,3,7),(0,2,7),(0,1,7)],[(1,0,8)],[(0,-1,9)],[(1,0,10)],[(0,-1,11)],[(0,-1,12)],[(-1,0,13)],[(0,-1,14)],[(-3,0,15),(-2,0,15),(-1,0,15),(0,-3,15),(0,-2,15),(0,-1,15),(3,0,15),(2,0,15),(1,0,15),(0,3,15),(0,2,15),(0,1,15)],[(-1,0,16)],[(-1,0,17)],[(-1,0,18,8)]]
    for x in range(15) :
        for y in range(15) :
            if (x,y) not in island : brows_map.append((x,y))
    print(f'brows_map : {brows_map}')
    print(f'path : {path}')
    return run_map(brows_map,path)

if __name__ == '__main__' : main()


    
# 1 Parcours de la map a  partir de (7,7) de manière concentrique
#   a) Si ma case n'est pas dans island, je selection
#   b) Sinon je prend la case suivant

# 2 Creation d'un parcours de 16 tours le plus concentrique possible
#   a) Si je parviens au 16 tours sans island et dans la map, je selection
#   b) S'il reste d'autres possibilite, je recommance un autre parcours depuis la mÃªme case
#   c) Si j'ai epuisee les possbilites (comment mesurer ?) je reparts Ã  1

# 3 Mesure de la dilution du parcours au tours 16. 
#   a) Si la dilution Ã  t.16 est superieur a  25 / 225 : je garde
#   b) Sinon je relance le parcours a  2 qui peut me rediriger vers 1
