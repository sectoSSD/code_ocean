# paramètres
current_map =[] # => map ou l'on supprime les starts non pertinent
map_cursor = () # => temp_start
brows_cursor = () #=> current_tile
current_brows = []
current_path = [] #=> temp_path

### fonction existante

def add (tuple_1, tuple_2,args='') :
    if args : return tuple_1[0] + tuple_2[0], tuple_1[1] + tuple_2[1], args
    else : return tuple_1[0] + tuple_2[0], tuple_1[1] + tuple_2[1]

def middle(xy) :
    x,y = xy
    return 7-abs(7-x) + 7-abs(7-y) + min(7-abs(7-x), 7-abs(7-y)) # Manhattan + Euclidienne

def in_island(x,y,island) :
    return (not (x,y) in island)

### New

def best_value(xy_list, function) :
    # ne fonction qu'avec une liste de tuples [(x,y),...]
    temp_value = 0
    temp_xy = (0,0)
    for xy in xy_list :
        cursor = function(xy)# 
        if cursor > temp_value :
            temp_value = cursor
            temp_xy = xy
    return temp_xy

def one_step(xy, island,current_brows,brows_map) : 
    # retourn une list de tuple contenant des cases sans island
    new_step = (1,0),(-1,0),(0,1),(0,-1)
    new_tile = []
    possible_new_tile = list(map(lambda x : add(xy,x), new_step))
    for tile in possible_new_tile :
        if tile in island or tile in current_brows or tile not in brows_map :
            pass
        else : new_tile.append(tile)
    return new_tile

def step(current_tile, next_tile) :
    return next_tile[0] - current_tile[0], next_tile[1] - current_tile[1]
 
def I_map(current_map) :

    while current_map :
        map_cursor = best_value(current_map, middle)
        print(f'map_cursor in I_map : {map_cursor}')
        return map_cursor
        # bad_brows,current_path deja definit
  
def II_brows(map_cursor,brows_map, island,current_map) :
    
    current_path = [] #=> temp_path
    bad_brows = []
    brows_cursor = map_cursor
    current_brows = [map_cursor]
    
    while len(current_path) != 16 :
        print(f'brows_cursor : {brows_cursor}')
        print(f'current_brows : {current_brows}')
        possible_next_tiles = one_step(brows_cursor, island, current_brows, brows_map)
        
        while possible_next_tiles :
            print(f'possible_next_tiles :{ possible_next_tiles}')
            next_tile = best_value(possible_next_tiles, middle)
            print(f'next_tile :{ next_tile}')
            current_brows.append(next_tile)
            if current_brows in bad_brows :
                current_brows.pop()
                possible_next_tiles.remove(next_tile)
            else :
                current_path.append(step(brows_cursor, next_tile))
                brows_cursor = next_tile
                break
        else :
            print('while possible_next_tiles ... ELSE')
            if brows_cursor == map_cursor :
                print(f'current_map BEFOR bad tile to brows path : {current_map}')
                current_map.remove((7,7))#current_map.remove(map_cursor)
                print(f'current_map AFTER bad tile to brows path : {current_map}')
                I_map(current_map)
            else :
                bad_brows.append(current_brows)
                print(f'bad brows : {bad_brows}')
                current_brows = [map_cursor]  
                brows_cursor = map_cursor
    else : 
        print(f'end of II_brows : {current_path}')
        return current_path

def III_dilution():
    return

# test :

def main():
    
    brows_map = [] # map de référence sans les îles
    island = []
    island = [(6,7),(7,6),(8,7),(7,8)]
    for x in range(15) :
        for y in range(15) :
            if in_island(x,y,island) : brows_map.append((x,y))
            
    current_map = brows_map.copy() # ???
            
    I = I_map(current_map)
    II = II_brows(I, brows_map, island,current_map)
    return II

if __name__ == '__main__' : main()


    
# 1 Parcours de la map a  partir de (7,7) de manière concentrique
#   a) Si ma case n'est pas dans island, je selection
#   b) Sinon je prend la case suivant

# 2 Creation d'un parcours de 16 tours le plus concentrique possible
#   a) Si je parviens au 16 tours sans island et dans la map, je selection
#   b) S'il reste d'autres possibilite, je recommance un autre parcours depuis la mÃªme case
#   c) Si j'ai epuisee les possbilites (comment mesurer ?) je reparts Ã  1

# 3 Mesure de la dilution du parcours au tours 16. 
#   a) Si la dilution Ã  t.16 est superieur a  25 / 225 : je garde
#   b) Sinon je relance le parcours a  2 qui peut me rediriger vers 1
