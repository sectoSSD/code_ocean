### paramÃ¨tre de test
island = [(2,2),(2,3),(3,2),(3,3)]


for x in range(15) :
    for y in range(15) :
        if in_island(x,y,island) : brows_map.append((x,y))
 ### fin
 
 ### fonction existante

def add (tuple_1, tuple_2,args='') :
    if args : return tuple_1[0] + tuple_2[0], tuple_1[1] + tuple_2[1], args
    else : return tuple_1[0] + tuple_2[0], tuple_1[1] + tuple_2[1]

def middle(x,y) :
    return 7-abs(7-x)+7-abs(7-y)


def in_island(x,y,island) :
    return (not (x,y) in island)

for x in range(15) :
    for y in range(15) :
        print(in_island(x,y,island))

def firs_lap(side):
    laps_to_charge_weapons = 16
    
    for xy in tile :
        while
        for laps in range(laps_to_charge_weapons):

### New I

def best_value(xy_list, function) :
    # ne fonction qu'avec une liste de tuples [(x,y),...]
    temp_value = 0
    temp_xy = (0,0)
    for xy in xy_list :
        cursor = function(xy)# 
        if cursor > temp_value :
            temp_value = cursor
            temp_xy = x,y
    return temp_xy

def one_step(xy, island,current_brows) : 
    # retourn une list de tuple contenant des cases sans island
    new_step = (1,0),(-1,0),(0,1),(0,-1)
    new_tile = list(map(lambda x : add(xy,x), new_step))
    for tile in new_tile :
        if tile in island or tile in current_brows:
            new_tile.remove(tile)
    return new_tile

def step(current_tile, next_tile) :
    return next_tile[0] - current_tile[0], next_tile[1] - current_tile[1]
          
def best_start(brows_map,island) :
    while brows_map :
        temp_start = best_value(brows_map, middle)
        current_tile = temp_start.copy()
        current_brows = [temp_start] # path along the way
        bad_brows = [] # brows already check
        temp_path = []
        while len(temp_path) != 16 :
            possible_next_tiles = one_step(current_tile,island, current_brows)
            while possible_next_tiles :
                next_tile = best_value(possible_next_tiles, middle)
                current_brows.append(next_tile)
                if current_brows in bad_brows :
                    current_brows.pop()
                    possible_next_tiles.remove(next_tile)
                else :
                    temp_path.append(step(curent_tile, next_tile))
                    current_tile = next_tile.copy()
            else :
                bad_brows.append(current_brows)
                current_brows = [temp_start]

    
            # on en est Ã  2 b il faudra faire des tests
        
    
# 1 Parcours de la map Ã  partir de (7,7) de maniÃ¨re concentrique
#   a) Si ma case n'est pas dans island, je selection
#   b) Sinon je prend la case suivant

# 2 CrÃ©ation d'un parcours de 16 tours le plus concentrique possible
#   a) Si je parviens au 16 tours sans island et dans la map, je selection
#   b) S'il reste d'autres possibilitÃ©, je recommance un autre parcours depuis la mÃªme case
#   c) Si j'ai Ã©puisÃ© les possbilitÃ©s (comment mesurer ?) je reparts Ã  1

# 3 Mesure de la dilution du parcours au tours 16. 
#   a) Si la dilution Ã  t.16 est supÃ©rieur Ã  25 / 225 : je garde
#   b) Sinon je relance le parcours Ã  2 qui peut me rediriger vers 1

