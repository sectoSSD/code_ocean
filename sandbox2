
def add (tuple_1, tuple_2, laps='',sector='') :
    if laps : return tuple_1[0] + tuple_2[0], tuple_1[1] + tuple_2[1], laps
    elif sector : return tuple_1[0] + tuple_2[0], tuple_1[1] + tuple_2[1], laps, sector
    else : return tuple_1[0] + tuple_2[0], tuple_1[1] + tuple_2[1]

def current_path(xy, path) : return list(map(lambda xy_path : add(xy, xy_path), path))

def off_side(xy, size) :
    off_side = False
    for i in xy :
        if size <= i or i < 0 : off_side = True
    return off_side

def sector(xy) :
    sector = {'1': [ 0, 5, 0, 5], '2' : [ 0, 5, 5,10], '3' : [ 0, 5,10,15],
              '4': [ 5,10, 0, 5], '5' : [ 5,10, 5,10], '6' : [ 5,10,10,15],
              '7': [10,15, 0, 5], '8' : [10,15, 5,10], '9' : [10,15,10,15]}
    for i in '123456789' : # 0 must be least
        if sector[i][0] <= xy[0] < sector[i][1] and sector[i][2] <= xy[1] < sector[i][3] : 
            return int(i)
            
def config_fork_map(dir_) :
    fork_map = {'fork' : {}, 'max' : {}, 'fork-index': {}, 'index-fork' : {}}
    index = 0
    for fork in range(len(dir_)) :
        if len(dir_[fork]) != 1 :
            fork_map['fork'][fork] = 0
            fork_map['max'][fork] = len(dir_[fork])
            fork_map['fork-index'][fork] = index
            fork_map['index-fork'][index] = fork
            index += 1
    return fork_map

def del_fork_map(fork_map, fork) :
    index = fork_map['fork-index'][fork] 
    for cursor in ['fork', 'max', 'fork-index'] : del fork_map[cursor][fork]
    del fork_map['index-fork'][index]
    return fork_map

def update_fork_map(fork, fork_map): 
    fork_map['fork'][fork] += 1
    while fork_map['fork'][fork] > fork_map['max'][fork] :
        index = fork_map['fork-index'][fork]
        index -= 1 if index - 1 >= 0 else 0
        fork_map = del_fork_map(fork_map, fork)
        try :
            fork = fork_map['index-fork'][index]
            fork_map['fork'][fork] += 1    
        except KeyError : break
    return fork_map

def blocking(cursor, play_map, sector):
    blocking = False
    if (    cursor['tile'] in play_map['island']
         or sect.get(cursor['dir_']) == sector(cursor['tile'])
         or off_side(cursor['tile'], play_map['size']) 
        ): blocking = True
    return blocking

####

def I_no_fork(dir_, sect, cursor, tile, fork, fork_map, brows_map, impediment, next_loop) :
    tile = add(dir_[cursor][0], tile)
    if tile not in brows_map or sect[cursor] != sect(dir_[cursor][0]):   
        impediment = True
        if fork :
            fork_map = update_fork_map(fork, fork_map, dir_)
            print(f'1Aa Obstacle avec embanchement avant : {tile} retour')
        else :
            print(f'1Ab Obstacle sans embanchement avant : tile = {tile} fin')
            next_loop = False
            
    elif cursor == len(dir_) - 1 :
        if impediment == False : possible_path += 1
        else : impediment = True
        if all(len(i) == 1 for i in path) :
            print(f'1Ba Bout de path sans embranchement avant : {possible_path} fin')
            next_loop = False
        else :
            print('1Bb Bout de path avec embranchement avant : retour')
            path[start_cursor].pop(0)
            cursor = start_cursor
            tile = start_tile
            impediment = True
    else :
        tile = add(path[cursor][0], tile)
        cursor = path[cursor][0][2]
        print(f'1C On avance cursor = {cursor}, tile = {tile}')      
    return cursor, branch, tile, possible_path, next_loop, impediment

def IIA_first_fork(path, cursor, tile, start_cursor, start_tile) :
    if all(len(k) == 1 for k in path[:cursor]) : 
        print(f'A : premier embranchement : startcursor {cursor}')
        return cursor, tile
    else : return  start_cursor, start_tile

def IIB_least_fork(path, cursor, tile, branch, brows_map, start_cursor, start_tile, impediment) :
    if branch == len(path[cursor]) - 1 :
        if add(path[cursor][branch], tile) not in  brows_map :
            impediment = False
            print(f'2Ba1 : dernière embranchement avec qqc après, dernière branche, obstacle, cursor = {cursor}, branche = {branch}, tile = {tile}, retour  ')
        else :
            tile = add(path[cursor][branch], tile)
            cursor = path[cursor][branch][2]
            print(f'2Ba2 : dernière embranchement avec qqc après, dernière branche On avance cursor = {cursor}, branche = {branch}, tile = {tile} ')
        path[start_cursor].pop(0)
        branch = 0
    else :
        if add(path[cursor][branch], tile) not in  brows_map :
            impediment = False
            print('2Bb1 : dernière embranchement avec qqc après, autre branche, obstacle : , cursor = {cursor}, branche = {branch}, tile = {tile}, retour')
        else :
            tile = add(path[cursor][branch], tile)
            cursor = path[cursor][branch][2]
            print(f'2Bb2 : dernière embranchement avec qqc après, autre branche cursor = {cursor}, branche = {branch}, tile = {tile}, on avance ')
        branch += 1
    return path, cursor, tile, branch, impediment

def IIC_least_fork_end_path(path, cursor, tile, branch, brows_map, start_cursor, start_tile, possible_path, impediment):
    if add(path[cursor][branch], tile) not in  brows_map :
        impediment = False
        print('2Ca : dernière embranchement obstacle : retour')
    if branch == len(path[cursor]) - 1 :
        path[start_cursor].pop(0)
        if impediment == True : possible_path += 1
        else : impediment = True
        branch = 0
        print('2Cb : dernière embranchement, dernière branche, Bout de path : retour')
    else : 
        if impediment == True : possible_path += 1
        else : impediment = True
        if start_cursor == cursor : path[cursor].pop(0) # on pop si rien avant
        else : branch += 1
        print('2Cc : dernière embranchement, autre branche, Bout de path : retour')
    cursor = start_cursor
    tile = start_tile
    return path, cursor, tile, branch, possible_path, impediment

def IID_other_fork(path, cursor, tile, start_cursor, start_tile, brows_map, impediment) :
    if add(path[cursor][0], tile) not in  brows_map: 
        impediment = False
        print('2Da Avec embranchement, obstacle : on avance')
    else :
        print(f'2Db On avance cursor = {cursor}, tile = {tile}')
    cursor = path[cursor][0][2]
    tile = add(path[cursor][0], tile)  
    return path, cursor, tile, impediment 

###

def run_map(play_map, dir_map, sect, fork_map) : 
    # brows_map designe une list de tuple sans les tuples des islands
    map_ = {}
    for tile in brows_map :
        map_[tile] = run_path(tile, island, size, sect, dir_map, fork_map)
        print(f'next_tile : {tile}')
    print(f'fin de run_map : {map_}')
    return map_

def run_path(tile, play_map, sect, dir_map, fork_map)
   # dir_= [ [()], [()], [(),(),()], [()], [()] ]
   # sect = { cursor : sector }
    cursor = {'dir_' : 0, 'fork' : '', 'tile' : tile }
    # 'dir_' main parameters select the move on dir_
    # fork : least embranchement si pas d'embranchement avant fork = ''
    # tile : tile where we are on the map
    controller = { 'next_loop' : True, 'blocking' : False,  'end_path' : False, 'update' : False}
    possible_path = 0 # possible path for this tile
    
    while True :
        
        "A : embranchement : oui / non , quel cursor "
        if cursor['dir_'] in fork_map['fork'] : cursor['fork'] = cursor['dir']
        "B : obstacle : " 
        controller['blocking'] = blocking(cursor, play_map, sector)
        "C : bout de path : " 
        controller['end_path'] = True if cursor['dir'] == len(path[cursor]) - 1 else False
        
        """
        "on a creer plein de variable dont :
        controller prévoit tout les cas de figure
        cursor actualise le position dans chacun des conteneurs
        fork_map : gère les parcours dans les embranchement
        
        A partir de tout ça il faut :
            - actualisé fork_map, et les cursors en fonction de tous les cas,
            - compter les possibles path
            - arrêter la boucle 
            - and so on ...
        
        """
        
            start_cursor, start_tile = IIA_first_fork(
                path, cursor, tile, start_cursor, start_tile)
            if all(len(i) == 1 for i in path[cursor+1:]) :
                if cursor != len(path) - 1 :
                    path, cursor, tile, branch, impediment = IIB_least_fork(
                        path, cursor, tile, branch, brows_map, start_cursor, start_tile, impediment)  
                else :
                    path, cursor, tile, branch, possible_path, impediment = IIC_least_fork_end_path(
                        path, cursor, tile, branch, brows_map, start_cursor, start_tile, possible_path, impediment)

            else :
                if any(len(i) != 1 for i in path[cursor+1:]) :
                    path, cursor, tile, impediment = IID_other_fork(
                        path, cursor, tile, start_cursor, start_tile, brows_map, impediment)
        
        else :
            cursor, tile_cursor, fork, fork_map, next_loop, impediment = I_no_fork(
                dir_, sect, cursor, tile, fork, fork_map, brows_map, impediment, next_loop)
        
        if end_path == True :
            if impediment == False : possible_path += 1
            
            if next_loop = True : 
                cursor = 0
                tile_cursor = tile 
            else : return possible_path
        
        else : 
            dir_cursor += 1
            tile_cursor = add(path[cursor][branch], tile)
            
def main():
    play_map = {'island' : [], 'size' : 15}
    sector = {} # { cursor : sector }
    dir_map = [[(-1, 0, 0)], [(0, 1, 0)], [(1, 0, 0)], [(1, 0, 0)], [(0, -1, 0)], [(0, -1, 0)], 
              [(-1, 0, 0)], [(-1, 0, 0)], [(-1, 0, 0)], [(0, 1, 0)], [(0, 1, 0)], 
              [(0, 1, 0), (1,0,0)],
              [(0, 1, 0)],[(0, 1, 0)],[(0, 1, 0)],
              [(0, 1, 0),(1, 0, 0)]]
    fork_map = config_fork_map(dir_) # map of embranchement       
    print(f"play_map : {play_map['island'}}")
    print(f'path : {dir_}')
    return run_map(play_map, dir_map, sector, fork_map)

if __name__ == '__main__' : main()

# PROCHAINE ETAPE : INTEGRER LES SECTORS
